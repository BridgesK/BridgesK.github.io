<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021红帽杯签到题--EBCDIC</title>
    <url>/2021/07/09/2021%E7%BA%A2%E5%B8%BD%E6%9D%AF%E7%AD%BE%E5%88%B0%E9%A2%98-EBCDIC/</url>
    <content><![CDATA[<h2 id="2021红帽杯签到题–EBCDIC"><a href="#2021红帽杯签到题–EBCDIC" class="headerlink" title="2021红帽杯签到题–EBCDIC"></a>2021红帽杯签到题–EBCDIC</h2><p>打开文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">啌亣捆咇凁攨mｐm檯剤仯蝠蝰?</span><br></pre></td></tr></table></figure>

<p>用kali转码，将ebcdic编码转位ascii编码</p>
<p><img src="/2021/07/09/2021%E7%BA%A2%E5%B8%BD%E6%9D%AF%E7%AD%BE%E5%88%B0%E9%A2%98-EBCDIC/hello.png"></p>
<span id="more"></span>

<p><img src="/2021/07/09/2021%E7%BA%A2%E5%B8%BD%E6%9D%AF%E7%AD%BE%E5%88%B0%E9%A2%98-EBCDIC/good.png"></p>
<p>打开FILE.txt即得flag</p>
]]></content>
      <categories>
        <category>CTF赛题总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Guess-the-Number</title>
    <url>/2022/01/21/Guess-the-Number/</url>
    <content><![CDATA[<h2 id="Guess-the-Number"><a href="#Guess-the-Number" class="headerlink" title="Guess-the-Number"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=1&id=4908&page=1">Guess-the-Number</a></h2><p>得到jar文件，用<a href="http://java-decompiler.github.io/">jd-gui</a>反编译得到如下源码</p>
<span id="more"></span>

<p><img src="/2022/01/21/Guess-the-Number/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-21%20122902.png"></p>
<p>点击File -&gt; Save，将其打包为.java文件</p>
<p><img src="/2022/01/21/Guess-the-Number/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-21%20123042.png"></p>
<p>在vscode中搭建java环境，打开guess.java，修改代码如下</p>
<p><img src="/2022/01/21/Guess-the-Number/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-21%20123539.png"></p>
<p>运行既得flag</p>
<p><img src="/2022/01/21/Guess-the-Number/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-21%20123802.png"></p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>KnightCTF 2022 wp</title>
    <url>/2022/01/23/KnightCTF-2022-wp/</url>
    <content><![CDATA[<p>这个比赛是一个对新人很友好的比赛，不过也能学到一些知识</p>
<h2 id="The-Flag-Vault"><a href="#The-Flag-Vault" class="headerlink" title="The_Flag_Vault"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/The_Flag_Vault">The_Flag_Vault</a></h2><p>64位elf文件</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20224231.png"></p>
<span id="more"></span>

<p>用ida打开，发现程序将输入的字符串存入s2中，与s1字符串比较，若相同则输出正确的flag</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20224627.png"></p>
<p>所以我们只需要运行程序并输入s1字符串即可得到flag</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/Screenshot_2022-01-23_09-56-20.png"></p>
<h2 id="The-Encoder"><a href="#The-Encoder" class="headerlink" title="The Encoder"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/the_encoder.out">The Encoder</a></h2><p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20230847.png"></p>
<p>64位无壳</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20230031.png"></p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20230448.png"></p>
<p>用它给出的数据减去1337既得flag</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">encoder</span> <span class="string">=</span> [<span class="number">1412</span>, <span class="number">1404</span>, <span class="number">1421</span>, <span class="number">1407</span>, <span class="number">1460</span>, <span class="number">1452</span>, <span class="number">1386</span>, <span class="number">1414</span>, <span class="number">1449</span>, <span class="number">1445</span>,</span><br><span class="line">           <span class="number">1388</span>, <span class="number">1432</span>, <span class="number">1388</span>, <span class="number">1415</span>, <span class="number">1436</span>, <span class="number">1385</span>, <span class="number">1405</span>, <span class="number">1388</span>, <span class="number">1451</span>, <span class="number">1432</span>,</span><br><span class="line">           <span class="number">1386</span>, <span class="number">1388</span>, <span class="number">1388</span>, <span class="number">1392</span>, <span class="number">1462</span>]</span><br><span class="line"><span class="string">v7</span> <span class="string">=</span> <span class="number">1337</span></span><br><span class="line"><span class="string">flag</span> <span class="string">=</span> []</span><br><span class="line"><span class="string">for</span> <span class="string">i</span> <span class="string">in</span> <span class="string">range(len(encoder)):</span></span><br><span class="line">    <span class="string">flag.append(encoder[i]</span> <span class="bullet">-</span> <span class="string">v7)</span></span><br><span class="line"><span class="string">print(flag)</span></span><br><span class="line"><span class="string">for</span> <span class="string">i</span> <span class="string">in</span> <span class="string">range(len(flag)):</span></span><br><span class="line">    <span class="string">print(chr(flag[i]),end=&#x27;&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="Baby-Shark"><a href="#Baby-Shark" class="headerlink" title="Baby Shark"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/babyshark.jar">Baby Shark</a></h2><p>这道题我最开始一直以为是音频隐写，后来发现并不是，用<a href="http://java-decompiler.github.io/">jd-gui</a>打开</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20231519.png"></p>
<p>将0xflag对应部分用base64解密(<a href="http://www.hiencode.com/base64.html">base64解密网站</a>)</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20231937.png"></p>
<h2 id="Flag-Checker"><a href="#Flag-Checker" class="headerlink" title="Flag Checker"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/flag_checker">Flag Checker</a></h2><p>将文件用ida打开，找到main函数如下</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc,<span class="built_in"> const </span>char **argv,<span class="built_in"> const </span>char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4[512]; // [rsp+0h] [rbp-240h] BYREF</span><br><span class="line">  char v5[51]; // [rsp+200h] [rbp-40h] BYREF</span><br><span class="line">  char v6; // [rsp+233h] [rbp-Dh]</span><br><span class="line"> <span class="built_in"> int </span>v7; // [rsp+234h] [rbp-Ch]</span><br><span class="line"> <span class="built_in"> int </span>j; // [rsp+238h] [rbp-8h]</span><br><span class="line"> <span class="built_in"> int </span>i; // [rsp+23Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  strcpy(v5, <span class="string">&quot;08&#x27;5[Z&#x27;Y:H3?X2K3V)?D2G3?H,N6?G$R(G]&quot;</span>);</span><br><span class="line">  printf(<span class="string">&quot;Give me a flag : &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v4);</span><br><span class="line">  for ( i = 0; v4[i]; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( v4[i] &lt;= 64 || v4[i] &gt; 90 )</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in"> if </span>( v4[i] &lt;= 96 || v4[i] &gt; 122 )</span><br><span class="line">        v4[i] = v4[i];</span><br><span class="line">      else</span><br><span class="line">        v4[i] = -37 - v4[i];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      v4[i] = -101 - v4[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for ( j = 0; v4[j]; ++j )</span><br><span class="line">    v4[j] -= 32;</span><br><span class="line">  v7 = 0;</span><br><span class="line">  v6 = 0;</span><br><span class="line">  while ( v5[v7] )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( v5[v7] != v4[v7] )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = 0;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 = 1;</span><br><span class="line">    ++v7;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in"> if </span>( v6 )</span><br><span class="line">    puts(<span class="string">&quot;You have entered the right flag.&quot;</span>);</span><br><span class="line">  else</span><br><span class="line">    puts(<span class="string">&quot;Sorry ! Its wrong flag.&quot;</span>);</span><br><span class="line"> <span class="built_in"> return </span>0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由伪代码可知，程序将flag存入v4中，经过一系列加密后与v5字符串进行比较，所以只需要将已知的v5字符串解密即得flag，注意v4中每个元素的范围都在ascii码的范围内，所以要将运算结果对128取余，脚本如下</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">v5 = <span class="string">&quot;08&#x27;5[Z&#x27;Y:H3?X2K3V)?D2G3?H,N6?G$R(G]&quot;</span></span><br><span class="line">coded_flag = []</span><br><span class="line">for x in v5:</span><br><span class="line">    coded_flag.append(ord(x) + <span class="number">32</span>)</span><br><span class="line">for i in range(len(coded_flag)):</span><br><span class="line">    if <span class="number">90</span> &lt; coded_flag[i] &lt;= <span class="number">96</span> or coded_flag[i] &gt; <span class="number">122</span> or coded_flag[i] &lt;= <span class="number">64</span>:</span><br><span class="line">        coded_flag[i] = coded_flag[i]</span><br><span class="line">    elif <span class="number">96</span> &lt; coded_flag[i] &lt;= <span class="number">122</span>:</span><br><span class="line">        coded_flag[i] = (<span class="number">-37</span> - coded_flag[i])<span class="comment">%128</span></span><br><span class="line">    else:</span><br><span class="line">        coded_flag[i] = (<span class="number">-101</span> - coded_flag[i])<span class="comment">%128</span></span><br><span class="line">for z in coded_flag:</span><br><span class="line">    print(chr(z), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行即得flag</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20100119.png"></p>
<h2 id="Knight-Vault"><a href="#Knight-Vault" class="headerlink" title="Knight Vault"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/ks_vault">Knight Vault</a></h2><p>ida反编译如下</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc,<span class="built_in"> const </span>char **argv,<span class="built_in"> const </span>char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4; // [rsp+Bh] [rbp-435h]</span><br><span class="line"> <span class="built_in"> int </span>i; // [rsp+Ch] [rbp-434h]</span><br><span class="line"> <span class="built_in"> int </span>v6; // [rsp+Ch] [rbp-434h]</span><br><span class="line">  char v7[48]; // [rsp+10h] [rbp-430h] BYREF</span><br><span class="line">  char v8[1016]; // [rsp+40h] [rbp-400h] BYREF</span><br><span class="line">  unsigned __int64 v9; // [rsp+438h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  strcpy(v7, <span class="string">&quot;*9J&lt;qiEUoEkU]EjUc;U]EEZU`EEXU^7fFoU^7Y*_D]s&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;Hello There..\nWelcome to KS Vault.&quot;</span>);</span><br><span class="line">  printf(<span class="string">&quot;Please enter vault password : &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v8);</span><br><span class="line">  for ( i = 0; v8[i]; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v8[i + 512] = v8[i] - 10;</span><br><span class="line">   <span class="built_in"> if </span>( v8[i + 512] == 65 )</span><br><span class="line">      v8[i + 512] = 42;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = 0;</span><br><span class="line">  v4 = 0;</span><br><span class="line">  while ( v7[v6] )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( v7[v6] != v8[v6 + 512] )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = 0;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    v4 = 1;</span><br><span class="line">    ++v6;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in"> if </span>( v4 )</span><br><span class="line">    win();</span><br><span class="line">  else</span><br><span class="line">    puts(<span class="string">&quot;Wrong password !&quot;</span>);</span><br><span class="line"> <span class="built_in"> return </span>0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密脚本如下</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">encoded_flag = <span class="string">&#x27;*9J&lt;qiEUoEkU]EjUc;U]EEZU`EEXU^7fFoU^7Y*_D]s&#x27;</span></span><br><span class="line"><span class="built_in">flag</span> = []</span><br><span class="line"><span class="keyword">for</span> i <span class="built_in">in</span> encoded_flag:</span><br><span class="line">    <span class="keyword">if</span> ord(i) == <span class="number">42</span>:</span><br><span class="line">        <span class="built_in">flag</span>.<span class="built_in">append</span>(<span class="number">75</span>)</span><br><span class="line">    <span class="keyword">else</span>:<span class="built_in">flag</span>.<span class="built_in">append</span>(ord(i) + <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="built_in">in</span> range(len(<span class="built_in">flag</span>)):</span><br><span class="line">    print(chr(<span class="built_in">flag</span>[i]), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行得flag</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20103753.png"></p>
<h2 id="Knight-Switch-Bank"><a href="#Knight-Switch-Bank" class="headerlink" title="Knight Switch Bank"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/ks_switch_bank.out">Knight Switch Bank</a></h2><p>这道题也是给出了加密后的字符串以及加密过程，求出加密前的字符串即得flag</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc,<span class="built_in"> const </span>char **argv,<span class="built_in"> const </span>char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4[512]; // [rsp+0h] [rbp-430h]</span><br><span class="line">  char v5[512]; // [rsp+200h] [rbp-230h] BYREF</span><br><span class="line">  char v6[32]; // [rsp+400h] [rbp-30h] BYREF</span><br><span class="line"> <span class="built_in"> int </span>i; // [rsp+420h] [rbp-10h]</span><br><span class="line">  char v8; // [rsp+427h] [rbp-9h]</span><br><span class="line"> <span class="built_in"> int </span>v9; // [rsp+428h] [rbp-8h]</span><br><span class="line"> <span class="built_in"> int </span>v10; // [rsp+42Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  strcpy(v6, <span class="string">&quot;ZRIU]HdANdJAGDIAxIAvDDsAyDDq_&quot;</span>);</span><br><span class="line">  v10 = 0;</span><br><span class="line">  v9 = 0;</span><br><span class="line">  puts(<span class="string">&quot;-------------------------------------&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;\tKnight Switch Bank&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;--------------------------------------&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;Welcome to Knight Switch Bank....&quot;</span>);</span><br><span class="line">  printf(<span class="string">&quot;Please enter your password : &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v5);</span><br><span class="line">  while ( v5[v10] )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( v5[v10] &lt;= 64 || v5[v10] &gt; 77 )</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="built_in"> if </span>( v5[v10] &lt;= 96 || v5[v10] &gt; 109 )</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="built_in"> if </span>( v5[v10] &lt;= 77 || v5[v10] &gt; 90 )</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="built_in"> if </span>( v5[v10] &lt;= 109 || v5[v10] &gt; 122 )</span><br><span class="line">            v4[v10] = v5[v10] - 32;</span><br><span class="line">          else</span><br><span class="line">            v4[v10] = v5[v10] - 13;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v4[v10] = v5[v10] - 13;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        v4[v10] = v5[v10] + 13;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      v4[v10] = v5[v10] + 13;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v10;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4[v9] )</span><br><span class="line">    v4[v9++] += 2;</span><br><span class="line">  v8 = 0;</span><br><span class="line">  for ( i = 0; v6[i]; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( v6[i] != v4[i] )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = 0;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    v8 = 1;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in"> if </span>( v8 )</span><br><span class="line">    winner();</span><br><span class="line">  else</span><br><span class="line">    puts(<span class="string">&quot;Oh My God ! You entered a wrong password.&quot;</span>);</span><br><span class="line"> <span class="built_in"> return </span>0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，程序对不同范围的输入字符串进行了不同的加密，所以可以爆破求字符串</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">encoded_flag</span> = &#x27;ZRIU]HdANdJAGDIAxIAvDDsAyDDq_&#x27;</span><br><span class="line"><span class="attribute">flag</span> =<span class="meta"> []</span></span><br><span class="line"><span class="attribute">for</span> j in range(len(encoded_flag)):</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">0</span>, <span class="number">128</span>):</span><br><span class="line">        <span class="attribute">if</span> i &lt;= <span class="number">64</span> or i &gt; <span class="number">77</span>:</span><br><span class="line">            <span class="attribute">if</span> i &lt;= <span class="number">96</span> or i &gt; <span class="number">109</span>:</span><br><span class="line">                <span class="attribute">if</span> i &lt;= <span class="number">77</span> or i &gt; <span class="number">90</span>:</span><br><span class="line">                    <span class="attribute">if</span> i &lt;= <span class="number">109</span> or i &gt; <span class="number">122</span>:</span><br><span class="line">                        <span class="attribute">k</span> = i - <span class="number">32</span></span><br><span class="line">                    <span class="attribute">else</span>:</span><br><span class="line">                        <span class="attribute">k</span> = i - <span class="number">13</span></span><br><span class="line">                <span class="attribute">else</span>:</span><br><span class="line">                    <span class="attribute">k</span> = i - <span class="number">13</span></span><br><span class="line">            <span class="attribute">else</span>:</span><br><span class="line">                <span class="attribute">k</span> = i + <span class="number">13</span></span><br><span class="line">        <span class="attribute">else</span>:</span><br><span class="line">            <span class="attribute">k</span> = i + <span class="number">13</span></span><br><span class="line">        <span class="attribute">if</span> k == ord(encoded_flag[j]) - <span class="number">2</span>:</span><br><span class="line">            <span class="attribute">flag</span>.append(i)</span><br><span class="line"><span class="attribute">for</span> i in range(len(flag)):</span><br><span class="line">    <span class="attribute">print</span>(chr(flag[i]), end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行既得flag</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20103753.png"></p>
<h2 id="Droid-Flag"><a href="#Droid-Flag" class="headerlink" title="Droid Flag"></a><a href="https://github.com/BridgesK/CTF/blob/main/knightctf_2022/DroidFlag.apk">Droid Flag</a></h2><p>这道题比赛时我没有做出来，原因是不会寻找字符串</p>
<p>方法一，用jeb直接打开DroidFlag.apk，在MainActivity中可以看到，flag即为getS1()，getS3()，getS2()，getS4()几个函数的返回值拼接起来</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20110325.png"></p>
<p>双击getS1()，可以跳转到定义这几个函数的位置</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20110623.png"></p>
<p>可以看到，jeb已经将这几个字符串的值注释出来了，易得flag</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">s1=<span class="string">&quot;3LpM1s&quot;</span></span><br><span class="line">s3=<span class="string">&quot;D10RdNa&quot;</span></span><br><span class="line">s2=<span class="string">&quot;3Sr3V3r&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> = s1 + <span class="string">&quot;_&quot;</span> +s2+ <span class="string">&quot;_&quot;</span> +s3</span><br><span class="line"><span class="selector-tag">b</span> = <span class="selector-tag">a</span><span class="selector-attr">[::-1]</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&#x27;KCTF&#123;&#x27;</span>+b+<span class="string">&#x27;&#125;&#x27;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20111113.png"></p>
<p>另一种方法参考了这篇wp</p>
<p>[Droid Flag <a href="https://gist.github.com/Rajchowdhury420/b647ffcb541bcd4732760114b6aca0eb">Rev] Knight CTF 2022 (github.com)</a></p>
<p>首先将apktools复制到DroidFlag.apk所在的文件夹，执行如下命令</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20111519.png"></p>
<p>在values文件夹中找到strings.xml</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-23%20101219.png"></p>
<p>同样可以查看字符串</p>
<p><img src="/2022/01/23/KnightCTF-2022-wp/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-24%20111804.png"></p>
]]></content>
      <categories>
        <category>CTF赛题总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SUSCTF2022复盘</title>
    <url>/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/</url>
    <content><![CDATA[<h2 id="DigitalCircuits"><a href="#DigitalCircuits" class="headerlink" title="DigitalCircuits"></a><a href="https://github.com/BridgesK/CTF/blob/main/susctf2022_re/DigitalCircuits.zip">DigitalCircuits</a></h2><p>该文件为python打包成的exe文件，可以用如下方法判断：</p>
<p>1、python打包成的文件通常的图标都是python模样</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-02-28_165243.png"></p>
<p>2、用ExeinfoPe查看文件</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-02-28_165435.png"></p>
<span id="more"></span>

<p>3、ida载入文件，shift+f12查看字符串</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-02-28_170533.png"></p>
<p>判断出这一点，接下来我们的任务就是将.exe文件反编译出python源码了</p>
<p>参考这篇文章：(<a href="https://cloud.tencent.com/developer/article/1872447">别再问我exe反编译成Python脚本了！ - 云+社区 - 腾讯云 (tencent.com)</a>)</p>
<p>首先通过<a href="https://github.com/countercept/Python-exe-unpacker">pyinstxtractor.py</a>脚本提取pyc文件，引用参考文章中的方法</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-02-28_171524.png"></p>
<p>执行命令</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">python</span> pyinstxtractor.<span class="keyword">py</span> DigitalCircuits.<span class="keyword">exe</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-28%20172255.png"></p>
<p>生成了一个名为DigitalCircuits.exe_extracted的文件夹</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-28%20172446.png"></p>
<p>在文件夹内可以找到与可执行文件同名的.pyc文件，不过需要手动补后缀</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-02-28_172633.png"></p>
<p>下一步是还原文件头</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-28%20173222.png"></p>
<p>将pyc文件与同目录下的struct文件用十六进制编辑器打开对比</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-28%20174012.png"></p>
<p>发现缺少第一行的16个字节</p>
<p>先插入16个字节，再将struct中的第一行复制到pyc文件中</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-28%20174224.png"></p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-28%20174416.png"></p>
<p>保存，然后通过uncompyle6将pyc文件反编译为py文件</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">uncompyle6 -o <span class="module-access"><span class="module"><span class="identifier">DigitalCircuits</span>.</span></span>py <span class="module-access"><span class="module"><span class="identifier">DigitalCircuits</span>.</span></span>pyc</span><br></pre></td></tr></table></figure>

<p>代码如下，注释为个人分析</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># uncompyle6 version <span class="number">3.7</span>.<span class="number">4</span></span><br><span class="line"># Python bytecode <span class="number">3.7</span> (<span class="number">3394</span>)</span><br><span class="line"># Decompiled <span class="selector-tag">from</span>: Python <span class="number">3.7</span>.<span class="number">9</span> (tags/v3.<span class="number">7.9</span>:<span class="number">13</span>c94747c7, Aug <span class="number">17</span> <span class="number">2020</span>, <span class="number">18</span>:<span class="number">58</span>:<span class="number">18</span>) [MSC v.<span class="number">1900</span> <span class="number">64</span> bit (AMD64)]</span><br><span class="line"># Embedded file name: DigitalCircuits.py</span><br><span class="line"># Compiled at: <span class="number">1995</span>-<span class="number">09</span>-<span class="number">28</span> <span class="number">00</span>:<span class="number">18</span>:<span class="number">56</span></span><br><span class="line"># Size of source mod <span class="number">2</span>**<span class="number">32</span>: <span class="number">257</span> bytes</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def <span class="built_in">f1</span>(a, b):#与运算</span><br><span class="line">    if a == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        if b == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            return <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    return <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f2</span>(a, b):#或运算</span><br><span class="line">    if a == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        if b == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            return <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    return <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f3</span>(a):#非运算</span><br><span class="line">    if a == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        return <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    if a == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        return <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f4</span>(a, b):#异或运算</span><br><span class="line">    return <span class="built_in">f2</span>(<span class="built_in">f1</span>(a, <span class="built_in">f3</span>(b)), <span class="built_in">f1</span>(<span class="built_in">f3</span>(a), b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f5</span>(x, y, z):#全加器，s为和，c为进位</span><br><span class="line">    s = <span class="built_in">f4</span>(<span class="built_in">f4</span>(x, y), z)</span><br><span class="line">    c = <span class="built_in">f2</span>(<span class="built_in">f1</span>(x, y), <span class="built_in">f1</span>(z, <span class="built_in">f2</span>(x, y)))</span><br><span class="line">    return (s, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f6</span>(a, b):</span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    z = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    a = a[::-<span class="number">1</span>]#将a串逆序</span><br><span class="line">    b = b[::-<span class="number">1</span>]#将b串逆序</span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        ans += <span class="built_in">f5</span>(a[i], b[i], z)[<span class="number">0</span>]#按位相加存入ans</span><br><span class="line">        z = <span class="built_in">f5</span>(a[i], b[i], z)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    return ans[::-<span class="number">1</span>]#返回ans的逆序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f7</span>(a, n):</span><br><span class="line">    return a[n:] + <span class="string">&#x27;0&#x27;</span> * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f8</span>(a, n):</span><br><span class="line">    return n * <span class="string">&#x27;0&#x27;</span> + a[:-n]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f9</span>(a, b):</span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        ans += <span class="built_in">f4</span>(a[i], b[i])</span><br><span class="line"></span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f10</span>(v0, v1, k0, k1, k2, k3):#k0，k1，k2，k3均为常量，递归求解v0，v1</span><br><span class="line">    s = <span class="string">&#x27;00000000000000000000000000000000&#x27;</span></span><br><span class="line">    d = <span class="string">&#x27;10011110001101110111100110111001&#x27;</span></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        s = <span class="built_in">f6</span>(s, d)</span><br><span class="line">        v0 = <span class="built_in">f6</span>(v0, <span class="built_in">f9</span>(<span class="built_in">f9</span>(<span class="built_in">f6</span>(<span class="built_in">f7</span>(v1, <span class="number">4</span>), k0), <span class="built_in">f6</span>(v1, s)), <span class="built_in">f6</span>(<span class="built_in">f8</span>(v1, <span class="number">5</span>), k1)))</span><br><span class="line">        v1 = <span class="built_in">f6</span>(v1, <span class="built_in">f9</span>(<span class="built_in">f9</span>(<span class="built_in">f6</span>(<span class="built_in">f7</span>(v0, <span class="number">4</span>), k2), <span class="built_in">f6</span>(v0, s)), <span class="built_in">f6</span>(<span class="built_in">f8</span>(v0, <span class="number">5</span>), k3)))</span><br><span class="line"></span><br><span class="line">    return v0 + v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k0 = <span class="string">&#x27;0100010001000101&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">k1 = <span class="string">&#x27;0100000101000100&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">k2 = <span class="string">&#x27;0100001001000101&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">k3 = <span class="string">&#x27;0100010101000110&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">flag = <span class="built_in">input</span>(<span class="string">&#x27;please input flag:&#x27;</span>)</span><br><span class="line">if flag[<span class="number">0</span>:<span class="number">7</span>] != <span class="string">&#x27;SUSCTF&#123;&#x27;</span> or flag[(-<span class="number">1</span>)] != <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error!!!The formate of flag is SUSCTF&#123;XXX&#125;&#x27;</span>)</span><br><span class="line">    time.<span class="built_in">sleep</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">flagstr = flag[<span class="number">7</span>:-<span class="number">1</span>]</span><br><span class="line">if <span class="built_in">len</span>(flagstr) != <span class="number">24</span>:#flagstr长度为<span class="number">24</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error!!!The length of flag 24&#x27;</span>)</span><br><span class="line">    time.<span class="built_in">sleep</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>)</span><br><span class="line">else:</span><br><span class="line">    res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(flagstr), <span class="number">8</span>):#每次传入flagstr中的<span class="number">8</span>位，共能循环<span class="number">3</span>次</span><br><span class="line">        v0 = flagstr[i:i + <span class="number">4</span>]</span><br><span class="line">        v0 = <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[i]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">1</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">2</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">3</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>)</span><br><span class="line">        v1 = <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">4</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">5</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">6</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>) + <span class="built_in">bin</span>(<span class="built_in">ord</span>(flagstr[(i + <span class="number">7</span>)]))[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">8</span>)</span><br><span class="line">        res += <span class="built_in">f10</span>(v0, v1, k0, k1, k2, k3)</span><br><span class="line"></span><br><span class="line">    if res == <span class="string">&#x27;001111101000100101000111110010111100110010010100010001100011100100110001001101011000001110001000001110110000101101101000100100111101101001100010011100110110000100111011001011100110010000100111&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</span><br><span class="line">    else:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;False&#x27;</span>)</span><br><span class="line">time.<span class="built_in">sleep</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>解题脚本如下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">def f1(<span class="selector-tag">a</span>, <span class="selector-tag">b</span>):#与运算</span><br><span class="line">    if a == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        if b == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            return <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    return <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f2</span>(a, b):#或运算</span><br><span class="line">    if a == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        if b == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            return <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    return <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f3</span>(a):#非运算</span><br><span class="line">    if a == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        return <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    if a == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        return <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f4</span>(a, b):#异或运算</span><br><span class="line">    return <span class="built_in">f2</span>(<span class="built_in">f1</span>(a, <span class="built_in">f3</span>(b)), <span class="built_in">f1</span>(<span class="built_in">f3</span>(a), b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f5</span>(x, y, z):#全加器，s为和，c为进位</span><br><span class="line">    s = <span class="built_in">f4</span>(<span class="built_in">f4</span>(x, y), z)</span><br><span class="line">    c = <span class="built_in">f2</span>(<span class="built_in">f1</span>(x, y), <span class="built_in">f1</span>(z, <span class="built_in">f2</span>(x, y)))</span><br><span class="line">    return (s, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f6</span>(a, b):</span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    z = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    a = a[::-<span class="number">1</span>] #a逆序</span><br><span class="line">    b = b[::-<span class="number">1</span>] #b逆序</span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        ans += <span class="built_in">f5</span>(a[i], b[i], z)[<span class="number">0</span>]</span><br><span class="line">        z = <span class="built_in">f5</span>(a[i], b[i], z)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    return ans[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f6_decode</span>(a, c):#运用二进制运算的性质，通过补码求减</span><br><span class="line"></span><br><span class="line">    c = <span class="built_in">int</span>(c, <span class="number">2</span>) + (<span class="number">1</span> &lt;&lt; <span class="number">32</span>)</span><br><span class="line">    a = <span class="built_in">int</span>(a, <span class="number">2</span>)</span><br><span class="line">    b = (c - a) % (<span class="number">1</span> &lt;&lt; <span class="number">32</span>)</span><br><span class="line">    return <span class="built_in">str</span>(<span class="built_in">bin</span>(b)[<span class="number">2</span>:].<span class="built_in">zfill</span>(<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f7</span>(a, n):#舍弃前n个元素，在末尾补<span class="number">0</span></span><br><span class="line">    return a[n:] + <span class="string">&#x27;0&#x27;</span> * n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f8</span>(a, n):</span><br><span class="line">    return n * <span class="string">&#x27;0&#x27;</span> + a[:-n]#舍弃后n个元素，在开头补<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f9</span>(a, b): #按位异或</span><br><span class="line">    ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        ans += <span class="built_in">f4</span>(a[i], b[i])</span><br><span class="line"></span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">f10</span>(v0, v1, k0, k1, k2, k3):</span><br><span class="line">    s = <span class="string">&#x27;00000000000000000000000000000000&#x27;</span></span><br><span class="line">    d = <span class="string">&#x27;10011110001101110111100110111001&#x27;</span></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        s = <span class="built_in">f6</span>(s, d)</span><br><span class="line">        v0 = <span class="built_in">f6</span>(v0, <span class="built_in">f9</span>(<span class="built_in">f9</span>(<span class="built_in">f6</span>(<span class="built_in">f7</span>(v1, <span class="number">4</span>), k0), <span class="built_in">f6</span>(v1, s)), <span class="built_in">f6</span>(<span class="built_in">f8</span>(v1, <span class="number">5</span>), k1)))</span><br><span class="line">        v1 = <span class="built_in">f6</span>(v1, <span class="built_in">f9</span>(<span class="built_in">f9</span>(<span class="built_in">f6</span>(<span class="built_in">f7</span>(v0, <span class="number">4</span>), k2), <span class="built_in">f6</span>(v0, s)), <span class="built_in">f6</span>(<span class="built_in">f8</span>(v0, <span class="number">5</span>), k3)))</span><br><span class="line">    return v0+v1</span><br><span class="line"></span><br><span class="line">def <span class="built_in">f10_decode</span>(res, k0, k1, k2, k3):</span><br><span class="line">    v0 = res[<span class="number">0</span>:<span class="number">32</span>]</span><br><span class="line">    v1 = res[<span class="number">32</span>:<span class="number">64</span>]</span><br><span class="line">    s = <span class="string">&#x27;11000110111011110011011100100000&#x27;</span></span><br><span class="line">    d = <span class="string">&#x27;10011110001101110111100110111001&#x27;</span></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        v1 = <span class="built_in">f6_decode</span>(<span class="built_in">f9</span>(<span class="built_in">f9</span>(<span class="built_in">f6</span>(<span class="built_in">f7</span>(v0, <span class="number">4</span>), k2), <span class="built_in">f6</span>(v0, s)), <span class="built_in">f6</span>(<span class="built_in">f8</span>(v0, <span class="number">5</span>), k3)), v1)</span><br><span class="line">        v0 = <span class="built_in">f6_decode</span>(<span class="built_in">f9</span>(<span class="built_in">f9</span>(<span class="built_in">f6</span>(<span class="built_in">f7</span>(v1, <span class="number">4</span>), k0), <span class="built_in">f6</span>(v1, s)), <span class="built_in">f6</span>(<span class="built_in">f8</span>(v1, <span class="number">5</span>), k1)), v0)</span><br><span class="line">        s = <span class="built_in">f6_decode</span>(d, s)</span><br><span class="line">    return v0+v1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k0 = <span class="string">&#x27;0100010001000101&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>) #Python <span class="built_in">zfill</span>() 方法返回指定长度的字符串，原字符串右对齐，前面填充</span><br><span class="line">k1 = <span class="string">&#x27;0100000101000100&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">k2 = <span class="string">&#x27;0100001001000101&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">k3 = <span class="string">&#x27;0100010101000110&#x27;</span>.<span class="built_in">zfill</span>(<span class="number">32</span>)</span><br><span class="line">res = <span class="string">&#x27;0011111010001001010001111100101111001100100101000100011000111001&#x27;</span>\</span><br><span class="line">      <span class="string">&#x27;0011000100110101100000111000100000111011000010110110100010010011&#x27;</span> \</span><br><span class="line">      <span class="string">&#x27;1101101001100010011100110110000100111011001011100110010000100111&#x27;</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">res1 = res[<span class="number">0</span>:<span class="number">64</span>]</span><br><span class="line">res2 = res[<span class="number">64</span>:<span class="number">128</span>]</span><br><span class="line">res3 = res[<span class="number">128</span>:<span class="number">192</span>]</span><br><span class="line">flag += <span class="built_in">f10_decode</span>(res1, k0, k1, k2, k3)</span><br><span class="line">flag += <span class="built_in">f10_decode</span>(res2, k0, k1, k2, k3)</span><br><span class="line">flag += <span class="built_in">f10_decode</span>(res3, k0, k1, k2, k3)</span><br><span class="line">for i in <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(flag), <span class="number">8</span>):</span><br><span class="line">    a = <span class="built_in">int</span>(flag[i:i+<span class="number">8</span>], <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(a), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="更新："><a href="#更新：" class="headerlink" title="更新："></a>更新：</h2><p>看了大佬们的wp才发现这是个<a href="https://bridgesk.github.io/2022/03/02/Tea%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">tea</a>加密算法，只不过是二进制的而已，套用tea解密的脚本即可求得flag</p>
<p>这里贴的是Dest0g3 Team的脚本</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">def tea_decode(enc, k):</span><br><span class="line">    v0 = enc[<span class="number">0</span>]</span><br><span class="line">    v1 = enc[<span class="number">1</span>]</span><br><span class="line">    sum = (delta*<span class="number">32</span>)<span class="meta">&amp;0xffffffff</span></span><br><span class="line">    for i in range(<span class="number">32</span>):</span><br><span class="line">        v1 -= ((v0&lt;&lt;<span class="number">4</span>) + k[<span class="number">2</span>]) ^ (v0 + sum) ^ ((v0&gt;&gt;<span class="number">5</span>) + k[<span class="number">3</span>])</span><br><span class="line">        v1 <span class="meta">&amp;= 0xffffffff</span></span><br><span class="line">        v0 -= ((v1&lt;&lt;<span class="number">4</span>) + k[<span class="number">0</span>]) ^ (v1 + sum) ^ ((v1&gt;&gt;<span class="number">5</span>) + k[<span class="number">1</span>])</span><br><span class="line">        v0 <span class="meta">&amp;= 0xffffffff</span></span><br><span class="line">        sum -= delta</span><br><span class="line">    return (v0, v1)</span><br><span class="line"></span><br><span class="line">enc = &#x27;<span class="number">00111110100010</span><span class="number">01010001111100</span><span class="number">10111100110010</span><span class="number">01010001000110</span><span class="number">00111001001100</span><span class="number">01001101011000</span><span class="number">00111000100000</span><span class="number">11101100001011</span><span class="number">01101000100100</span><span class="number">11110110100110</span><span class="number">00100111001101</span><span class="number">10000100111011</span><span class="number">00101110011001</span><span class="number">0000100111</span>&#x27;</span><br><span class="line">enc = [int(enc[i:i+<span class="number">32</span>], <span class="number">2</span>) for i in range(<span class="number">0</span>, len(enc), <span class="number">32</span>)]</span><br><span class="line"></span><br><span class="line">k = [<span class="number">0</span>]*<span class="number">4</span></span><br><span class="line">k[<span class="number">0</span>] = int(&#x27;<span class="number">01000100010001</span>01&#x27;.zfill(<span class="number">32</span>), <span class="number">2</span>)</span><br><span class="line">k[<span class="number">1</span>] = int(&#x27;<span class="number">01000001010001</span>00&#x27;.zfill(<span class="number">32</span>), <span class="number">2</span>)</span><br><span class="line">k[<span class="number">2</span>] = int(&#x27;<span class="number">01000010010001</span>01&#x27;.zfill(<span class="number">32</span>), <span class="number">2</span>)</span><br><span class="line">k[<span class="number">3</span>] = int(&#x27;<span class="number">01000101010001</span>10&#x27;.zfill(<span class="number">32</span>), <span class="number">2</span>)</span><br><span class="line">delta = int(&#x27;<span class="number">10011110001101</span><span class="number">11011110011011</span><span class="number">1001</span>&#x27;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">flag = b&#x27;&#x27;</span><br><span class="line">for i in range(<span class="number">0</span>, len(enc), <span class="number">2</span>):</span><br><span class="line">    ans = tea_decode(enc[i:i+<span class="number">2</span>], k)</span><br><span class="line">    flag += ans[<span class="number">0</span>].to_bytes(<span class="number">4</span>, &#x27;big&#x27;)+ans[<span class="number">1</span>].to_bytes(<span class="number">4</span>, &#x27;big&#x27;)<span class="meta">#int.to_bytes(length, byteorder)</span></span><br><span class="line"></span><br><span class="line">print(b&#x27;SUSCTF&#123;&#x27;+flag+b&#x27;&#125;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Hell-world"><a href="#Hell-world" class="headerlink" title="Hell_world"></a><a href="https://github.com/BridgesK/CTF/blob/main/susctf2022_re/hell_world.zip">Hell_world</a></h2><p>​    这道题比赛的时候没有思路，刚刚照着大佬们的wp复现了一下，虽然只是懂了个大概，但还是记录一下</p>
<p>​    引用SU战队的话，“跟西湖论剑题目gghdl差不多 就是改了下case结构和数据可以根据<a href="http://blog.bluesadi.cn/2021/11/24/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91gghdl%E9%A2%98%E8%A7%A3/">链接</a>来解题”</p>
<p>​    拿到程序，ida打开后首先shift+f12搜索字符串，search含有<code>flag</code></p>
<p>的字符串</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-03-02%20175344.png"></p>
<p>之后就是解析每个case函数的作用</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_125935.png"></p>
<p>然后我们通过动态调试的方法找到读取输入的函数</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_132925.png"></p>
<p>再分析case3</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_133221.png"></p>
<p>如果输入长度是44位的话就执行case4，进而执行case9，所以推测case9是加密函数</p>
<p>在分析case9之前，先查看输出正确的条件</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_134327.png"></p>
<p>正确条件为*(_DWORD <em>)(a1 + 376) &#x3D;&#x3D; 44，因此我们需要查看修改</em>(_DWORD *)(a1 + 376) 值的位置，发现只在case11中出现</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_155124.png"></p>
<p>追踪传入sub_7FF629329CC0函数的v74， v71，可以追踪到图中标出的关键函数，此函数在程序中共调用了3次，另外两次分别在case10和case9中，其中case9的该函数传入的为我们输入的数据(存在a1中)</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_160358.png"></p>
<p>因此我们可以动态调试分析该函数的功能，传入字符串<code>0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUI</code></p>
<p>常用字符<code>0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#123;&#125;_-</code></p>
<p>运行case9中的sub_7FF629350180函数,查看对应的汇编代码</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_161602.png"></p>
<p>查看函数返回值（存在rax寄存器中）</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/2022-03-03_161932.png"></p>
<p>其中22332222即为传入字符串中0对应的二进制码00110000每位加二，所以函数的功能其实就是字符串转换为对应的二进制</p>
<p>再查看sub_7FF629329CC0函数的汇编代码，发现就是异或运算</p>
<p><img src="/2022/03/01/SUSCTF2022%E5%A4%8D%E7%9B%98/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-03-03%20162506.png"></p>
<p>所以flag就是将dword_7FF629415B80和dword_7FF629415C50中的数据异或即可</p>
]]></content>
      <categories>
        <category>CTF赛题总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>GKCTF 2021 SoMuchCode</title>
    <url>/2021/10/20/SoMuchCode/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Tea加密算法总结</title>
    <url>/2022/03/02/Tea%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>​    在SUSCTF的DigitalCircuits题目中遇到了Tea加密算法，由于没有认出这一算法浪费了大量解题时间，所以特意写这篇博客总结学习一下该类算法的特点</p>
<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>​    TEA（Tiny Encryption Algorithm），是一种分组加密算法，实现过程比较简单，效率极高，该系列共三种算法，tea–&gt;xtea–&gt;xxtea，该算法使用了一个来源于<strong>黄金比率</strong>神秘常数<strong>δ</strong>作为倍数，<strong>以保证每一轮加密都不相同</strong>，这个常熟在程序中一般写作<code>0x9E3779B9</code>。但有时该常数会以减法的形式出现，<code>-0x61C88647=0x9E3779B9</code>，因此出现了<code>0x61C88647</code>该常数时也应当注意。</p>
<span id="more"></span>

<h2 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a><a href="https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm">TEA</a></h2><p>加密过程:</p>
<p><img src="/2022/03/02/Tea%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/1.png"></p>
<p>Python实现</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">def</span> encrypt(v, k):</span><br><span class="line">    <span class="attribute">v0</span> = v[<span class="number">0</span>]</span><br><span class="line">    <span class="attribute">v1</span> = v[<span class="number">1</span>]</span><br><span class="line">    <span class="attribute">x</span> = <span class="number">0</span></span><br><span class="line">    <span class="attribute">delta</span> = <span class="number">0</span>x9E3779B9</span><br><span class="line">    <span class="attribute">k0</span> = k[<span class="number">0</span>]</span><br><span class="line">    <span class="attribute">k1</span> = k[<span class="number">1</span>]</span><br><span class="line">    <span class="attribute">k2</span> = k[<span class="number">2</span>]</span><br><span class="line">    <span class="attribute">k3</span> = k[<span class="number">3</span>]</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">32</span>):</span><br><span class="line">        <span class="attribute">x</span> += delta</span><br><span class="line">        <span class="attribute">x</span> = x &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">v0</span> += ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1)</span><br><span class="line">        <span class="attribute">v0</span> = v0 &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">v1</span> += ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3)</span><br><span class="line">        <span class="attribute">v1</span> = v1 &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">    <span class="attribute">v</span>[<span class="number">0</span>] = v0</span><br><span class="line">    <span class="attribute">v</span>[<span class="number">1</span>] = v1</span><br><span class="line">    <span class="attribute">return</span> v</span><br><span class="line">    </span><br><span class="line"><span class="attribute">def</span> decrypt(v, k):</span><br><span class="line">    <span class="attribute">v0</span> = v[<span class="number">0</span>]</span><br><span class="line">    <span class="attribute">v1</span> = v[<span class="number">1</span>]</span><br><span class="line">    <span class="attribute">x</span> = <span class="number">0</span>xC6EF3720</span><br><span class="line">    <span class="attribute">delta</span> = <span class="number">0</span>x9E3779B9</span><br><span class="line">    <span class="attribute">k0</span> = k[<span class="number">0</span>]</span><br><span class="line">    <span class="attribute">k1</span> = k[<span class="number">1</span>]</span><br><span class="line">    <span class="attribute">k2</span> = k[<span class="number">2</span>]</span><br><span class="line">    <span class="attribute">k3</span> = k[<span class="number">3</span>]</span><br><span class="line">    <span class="attribute">for</span> i in range(<span class="number">32</span>):</span><br><span class="line">        <span class="attribute">v1</span> -= ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3)</span><br><span class="line">        <span class="attribute">v1</span> = v1 &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">v0</span> -= ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1)</span><br><span class="line">        <span class="attribute">v0</span> = v0 &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">x</span> -= delta</span><br><span class="line">        <span class="attribute">x</span> = x &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">    <span class="attribute">v</span>[<span class="number">0</span>] = v0</span><br><span class="line">    <span class="attribute">v</span>[<span class="number">1</span>] = v1</span><br><span class="line">    <span class="attribute">return</span> v</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a><a href="https://en.wikipedia.org/wiki/XTEA">XTEA</a></h2><p><code>XTEA</code> 是 <code>TEA</code> 的升级版，增加了更多的密钥表，移位和异或操作等等。</p>
<p>加密过程：</p>
<p><img src="/2022/03/02/Tea%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/2.png"></p>
<p>python实现：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">def encrypt(rounds, v, k):</span><br><span class="line">    v0 = v[0]</span><br><span class="line">    v1 = v[1]</span><br><span class="line">    x = 0</span><br><span class="line">    delta = 0x9E3779B9</span><br><span class="line">    for i in range(rounds):</span><br><span class="line">        v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3])</span><br><span class="line">        v0 = v0 &amp; 0xFFFFFFFF</span><br><span class="line">        x += delta</span><br><span class="line">        x = x &amp; 0xFFFFFFFF</span><br><span class="line">        v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3])</span><br><span class="line">        v1 = v1 &amp; 0xFFFFFFFF</span><br><span class="line">    v[0] = v0</span><br><span class="line">    v[1] = v1</span><br><span class="line">   <span class="built_in"> return </span>v</span><br><span class="line">def decrypt(rounds, v, k):</span><br><span class="line">    v0 = v[0]</span><br><span class="line">    v1 = v[1]</span><br><span class="line">    delta = 0x9E3779B9</span><br><span class="line">    x = delta * rounds</span><br><span class="line">    for i in range(rounds):</span><br><span class="line">        v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3])</span><br><span class="line">        v1 = v1 &amp; 0xFFFFFFFF</span><br><span class="line">        x -= delta</span><br><span class="line">        x = x &amp; 0xFFFFFFFF</span><br><span class="line">        v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3])</span><br><span class="line">        v0 = v0 &amp; 0xFFFFFFFF</span><br><span class="line">    v[0] = v0</span><br><span class="line">    v[1] = v1</span><br><span class="line">   <span class="built_in"> return </span>v</span><br></pre></td></tr></table></figure>

<h2 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a><a href="https://en.wikipedia.org/wiki/XXTEA">XXTEA</a></h2><p><code>XXTEA</code>，又称 <code>Corrected Block TEA</code>，是 <code>XTEA</code> 的升级版。</p>
<p>加密过程：</p>
<p><img src="/2022/03/02/Tea%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/3.png"></p>
<p>python实现：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">def</span> shift(z, y, x, k, p, e):</span><br><span class="line">    <span class="attribute">return</span> ((((z &gt;&gt; <span class="number">5</span>) ^ (y &lt;&lt; <span class="number">2</span>)) + ((y &gt;&gt; <span class="number">3</span>) ^ (z &lt;&lt; <span class="number">4</span>))) ^ ((x ^ y) + (k[(p &amp; <span class="number">3</span>) ^ e] ^ z)))</span><br><span class="line"><span class="attribute">def</span> encrypt(v, k):</span><br><span class="line">    <span class="attribute">delta</span> = <span class="number">0</span>x9E3779B9</span><br><span class="line">    <span class="attribute">n</span> = len(v)</span><br><span class="line">    <span class="attribute">rounds</span> = <span class="number">6</span> + <span class="number">52</span> / n</span><br><span class="line">    <span class="attribute">x</span> = <span class="number">0</span></span><br><span class="line">    <span class="attribute">z</span> = v[n - <span class="number">1</span>]</span><br><span class="line">    <span class="attribute">for</span> i in range(rounds):</span><br><span class="line">        <span class="attribute">x</span> = (x + delta) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">e</span> = (x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span></span><br><span class="line">        <span class="attribute">for</span> p in range(n - <span class="number">1</span>):</span><br><span class="line">            <span class="attribute">y</span> = v[p + <span class="number">1</span>]</span><br><span class="line">            <span class="attribute">v</span>[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">            <span class="attribute">z</span> = v[p]</span><br><span class="line">        <span class="attribute">p</span> += <span class="number">1</span></span><br><span class="line">        <span class="attribute">y</span> = v[<span class="number">0</span>]</span><br><span class="line">        <span class="attribute">v</span>[n - <span class="number">1</span>] = (v[n - <span class="number">1</span>] + shift(z, y, x, k, p, e)) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">z</span> = v[n - <span class="number">1</span>]</span><br><span class="line">    <span class="attribute">return</span> v</span><br><span class="line"><span class="attribute">def</span> decrypt(v, k):</span><br><span class="line">    <span class="attribute">delta</span> = <span class="number">0</span>x9E3779B9</span><br><span class="line">    <span class="attribute">n</span> = len(v)</span><br><span class="line">    <span class="attribute">rounds</span> = <span class="number">6</span> + <span class="number">52</span> / n</span><br><span class="line">    <span class="attribute">x</span> = (rounds * delta) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">    <span class="attribute">y</span> = v[<span class="number">0</span>]</span><br><span class="line">    <span class="attribute">for</span> i in range(rounds):</span><br><span class="line">        <span class="attribute">e</span> = (x &gt;&gt; <span class="number">2</span>) &amp; <span class="number">3</span></span><br><span class="line">        <span class="attribute">for</span> p in range(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="attribute">z</span> = v[p - <span class="number">1</span>]</span><br><span class="line">            <span class="attribute">v</span>[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">            <span class="attribute">y</span> = v[p]</span><br><span class="line">        <span class="attribute">p</span> -= <span class="number">1</span></span><br><span class="line">        <span class="attribute">z</span> = v[n - <span class="number">1</span>]</span><br><span class="line">        <span class="attribute">v</span>[<span class="number">0</span>] = (v[<span class="number">0</span>] - shift(z, y, x, k, p, e)) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">        <span class="attribute">y</span> = v[<span class="number">0</span>]</span><br><span class="line">        <span class="attribute">x</span> = (x - delta) &amp; <span class="number">0</span>xFFFFFFFF</span><br><span class="line">    <span class="attribute">return</span> v</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://qianfei11.github.io/2019/08/22/Python%E5%AE%9E%E7%8E%B0TEA%E3%80%81XTEA%E3%80%81XXTEA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/">Python实现TEA、XTEA、XXTEA加密解密算法 - B3ale (qianfei11.github.io)</a></p>
<p><a href="https://blog.csdn.net/A951860555/article/details/120073984"> tea系列加密算法学习笔记_lifanxin的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>csaw2013reversing2</title>
    <url>/2022/01/01/csaw2013reversing2/</url>
    <content><![CDATA[<h2 id="攻防世界csaw2013reversing2"><a href="#攻防世界csaw2013reversing2" class="headerlink" title="攻防世界csaw2013reversing2"></a>攻防世界<a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5081&page=1">csaw2013reversing2</a></h2><p>查壳，无壳</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20144716.png"></p>
<span id="more"></span>

<p>运行一下，发现是乱码</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20150323.png"></p>
<p>拖入ida中，找到main函数，f5查看伪代码</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20144918.png"></p>
<p>关键函数为IsDebuggerPresent，这个函数的作用是检测当前程序是否正在被调试，从图中可以看到，如果不是被调试，则会执行MessageBoxA函数，显示乱码。</p>
<p>关于IsDebuggerPresent函数与fs寄存器的介绍参考如下链接</p>
<p><a href="https://blog.csdn.net/ls1160/article/details/38105873#">(23条消息) 反调试技术- IsDebuggerPresent，原理 与 反反调试_desword– 技术，杂文。-CSDN博客_isdebuggerpresent</a></p>
<p><a href="https://www.cnblogs.com/dpblue/p/4850661.html">fs寄存器 - 深蓝无忌 - 博客园 (cnblogs.com)</a></p>
<p>查看汇编代码，发现int3中断</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20150805.png"></p>
<p>int3中断介绍</p>
<p><a href="https://blog.csdn.net/niuyisheng/article/details/9159895">(23条消息) int 3 软中断指令_niuyisheng的专栏-CSDN博客_int3中断</a></p>
<p>通过x64dbg动态调试，达到中断位置，即可求解</p>
<p>首先用x64dbg打开程序，设置在入口断点处停止</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20151332.png"></p>
<p>可以看到如图情况</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20151225.png"></p>
<p>F9运行，即可运行至int3断点的位置</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20151601.png"></p>
<p>我们注意到mov指令就是将flag的地址存入edx中，所以我们要执行这条语句，但由于int3，无法直接F8运行，可以先将int3用nop代替，在int3处按下空格键即可进行patch</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20151858.png"></p>
<p>F8运行后，注意到寄存器窗口EDX的值发生变化</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20152047.png"></p>
<p>右键选择在内存中转到</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20152228.png"></p>
<p>然后在F8运行call函数即可得到flag</p>
<p><img src="/2022/01/01/csaw2013reversing2/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-01%20152428.png"></p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>dmd-50</title>
    <url>/2022/02/15/dmd-50/</url>
    <content><![CDATA[<h2 id="dmd-50"><a href="#dmd-50" class="headerlink" title="dmd-50"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=1&id=4959&page=1">dmd-50</a></h2><p>64位elf文件</p>
<p><img src="/2022/02/15/dmd-50/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-15%20153330.png"></p>
<span id="more"></span>

<p>拖入ida中，反编译得main函数如下</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// rax</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// rax</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  __int64 v15; <span class="comment">// rax</span></span><br><span class="line">  __int64 v16; <span class="comment">// rax</span></span><br><span class="line">  __int64 v17; <span class="comment">// rax</span></span><br><span class="line">  __int64 v18; <span class="comment">// rax</span></span><br><span class="line">  __int64 v19; <span class="comment">// rax</span></span><br><span class="line">  __int64 v20; <span class="comment">// rax</span></span><br><span class="line">  __int64 v21; <span class="comment">// rax</span></span><br><span class="line">  __int64 v23; <span class="comment">// rax</span></span><br><span class="line">  __int64 v24; <span class="comment">// rax</span></span><br><span class="line">  __int64 v25; <span class="comment">// rax</span></span><br><span class="line">  __int64 v26; <span class="comment">// rax</span></span><br><span class="line">  __int64 v27; <span class="comment">// rax</span></span><br><span class="line">  __int64 v28; <span class="comment">// rax</span></span><br><span class="line">  __int64 v29; <span class="comment">// rax</span></span><br><span class="line">  __int64 v30; <span class="comment">// rax</span></span><br><span class="line">  __int64 v31; <span class="comment">// rax</span></span><br><span class="line">  __int64 v32; <span class="comment">// rax</span></span><br><span class="line">  __int64 v33; <span class="comment">// rax</span></span><br><span class="line">  __int64 v34; <span class="comment">// rax</span></span><br><span class="line">  __int64 v35; <span class="comment">// rax</span></span><br><span class="line">  __int64 v36; <span class="comment">// rax</span></span><br><span class="line">  __int64 v37; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v38; <span class="comment">// [rsp+Fh] [rbp-71h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v39[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v40[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-60h] BYREF</span></span><br><span class="line">  __int64 v41; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line">  <span class="keyword">char</span> v42[<span class="number">56</span>]; <span class="comment">// [rsp+30h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v43; <span class="comment">// [rsp+68h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v43 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;Enter the valid key!\n&quot;</span>, envp);</span><br><span class="line">  std::operator&gt;&gt;&lt;<span class="keyword">char</span>,std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;edata, v42);</span><br><span class="line">  std::allocator&lt;<span class="keyword">char</span>&gt;::allocator(&amp;v38);</span><br><span class="line">  std::string::string(v39, v42, &amp;v38);</span><br><span class="line">  md5((MD5 *)v40, (<span class="keyword">const</span> std::string *)v39);</span><br><span class="line">  v41 = std::string::c_str((std::string *)v40);</span><br><span class="line">  std::string::~<span class="keyword">string</span>((std::string *)v40);</span><br><span class="line">  std::string::~<span class="keyword">string</span>((std::string *)v39);</span><br><span class="line">  std::allocator&lt;<span class="keyword">char</span>&gt;::~allocator((__int64)&amp;v38);</span><br><span class="line">  <span class="keyword">if</span> ( *(_WORD *)v41 == <span class="number">14391</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">2</span>) == <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">3</span>) == <span class="string">&#x27;4&#x27;</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">4</span>) == <span class="string">&#x27;3&#x27;</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">5</span>) == <span class="number">56</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">6</span>) == <span class="number">100</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">7</span>) == <span class="number">53</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">8</span>) == <span class="number">98</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">9</span>) == <span class="number">54</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">10</span>) == <span class="number">101</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">11</span>) == <span class="number">50</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">12</span>) == <span class="number">57</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">13</span>) == <span class="number">100</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">14</span>) == <span class="number">98</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">15</span>) == <span class="number">48</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">16</span>) == <span class="number">56</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">17</span>) == <span class="number">57</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">18</span>) == <span class="number">56</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">19</span>) == <span class="number">98</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">20</span>) == <span class="number">99</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">21</span>) == <span class="number">52</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">22</span>) == <span class="number">102</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">23</span>) == <span class="number">48</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">24</span>) == <span class="number">50</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">25</span>) == <span class="number">50</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">26</span>) == <span class="number">53</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">27</span>) == <span class="number">57</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">28</span>) == <span class="number">51</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">29</span>) == <span class="number">53</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">30</span>) == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    &amp;&amp; *(_BYTE *)(v41 + <span class="number">31</span>) == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&#x27;T&#x27;</span>);</span><br><span class="line">    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v3, <span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v4, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v5, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v6, <span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">    v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v7, <span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v8, <span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">    v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v9, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v10, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v11, <span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v12, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v13, <span class="string">&#x27;v&#x27;</span>);</span><br><span class="line">    v15 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v14, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v15, <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    v17 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v16, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">    v18 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v17, <span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">    v19 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v18, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    v20 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v19, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">    v21 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v20, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    std::ostream::operator&lt;&lt;(v21, &amp;std::endl&lt;<span class="keyword">char</span>,std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v23 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;std::cout, <span class="number">73</span>LL);</span><br><span class="line">    v24 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v23, <span class="number">110</span>LL);</span><br><span class="line">    v25 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v24, <span class="number">118</span>LL);</span><br><span class="line">    v26 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v25, <span class="number">97</span>LL);</span><br><span class="line">    v27 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v26, <span class="number">108</span>LL);</span><br><span class="line">    v28 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v27, <span class="number">105</span>LL);</span><br><span class="line">    v29 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v28, <span class="number">100</span>LL);</span><br><span class="line">    v30 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v29, <span class="number">32</span>LL);</span><br><span class="line">    v31 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v30, <span class="number">75</span>LL);</span><br><span class="line">    v32 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v31, <span class="number">101</span>LL);</span><br><span class="line">    v33 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v32, <span class="number">121</span>LL);</span><br><span class="line">    v34 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v33, <span class="number">33</span>LL);</span><br><span class="line">    v35 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v34, <span class="number">32</span>LL);</span><br><span class="line">    v36 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v35, <span class="number">58</span>LL);</span><br><span class="line">    v37 = std::operator&lt;&lt;&lt;std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(v36, <span class="number">40</span>LL);</span><br><span class="line">    std::ostream::operator&lt;&lt;(v37, &amp;std::endl&lt;<span class="keyword">char</span>,std::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第49行调用md5加密，整理得加密后的字符串为</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">780438d</span>5b6e29db0898bc4f<span class="number">0225935c0</span></span><br></pre></td></tr></table></figure>

<p>在线解密</p>
<p><img src="/2022/02/15/dmd-50/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-15%20154517.png"></p>
<p>从类型中可知，这是进行了2次md5解密，所以flag就是将grape进行md5加密一次</p>
<p><img src="/2022/02/15/dmd-50/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-15%20154939.png"></p>
<p>得flag即为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">b<span class="number">781</span>cbb<span class="number">29054</span>db<span class="number">12</span>f<span class="number">88</span>f<span class="number">08</span><span class="keyword">c</span><span class="number">6e161</span><span class="keyword">c</span><span class="number">199</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>getit</title>
    <url>/2022/01/03/getit/</url>
    <content><![CDATA[<h2 id="攻防世界getit"><a href="#攻防世界getit" class="headerlink" title="攻防世界getit"></a>攻防世界<a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5082&page=1">getit</a></h2><p>查壳，无壳，为64为elf文件</p>
<p><img src="/2022/01/03/getit/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-02%20201618.png"></p>
<span id="more"></span>

<p>main函数如图所示，意思是生成一个flag，将它写入flag.txt，并最后将文件删除，所以我们只需要找到要写入flag.txt前的flag即可</p>
<p><img src="/2022/01/03/getit/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-02%20201818.png"></p>
<p>查看对应汇编代码，注意到这部分的strlen，和fseek即对应写入文件前的代码</p>
<p><img src="/2022/01/03/getit/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-02%20202303.png"></p>
<p>用pwndbg在0x400832处下断点，即可查看flag的值</p>
<p><img src="/2022/01/03/getit/Screenshot_2022-01-02_07-25-43.png"></p>
<p>其中，edi寄存器保存处理后的数据的内存地址，而该地址中的数据即为flag</p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>no-strings-attached</title>
    <url>/2021/12/31/no-strings-attached/</url>
    <content><![CDATA[<h2 id="攻防世界-no-strings-attached"><a href="#攻防世界-no-strings-attached" class="headerlink" title="攻防世界 no-strings-attached"></a>攻防世界 <a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5080&page=1">no-strings-attached</a></h2><p>32位文件，用ida打开后可以ctrl+f找到main函数，其中authenticate中包含加密函数</p>
<p><img src="/2021/12/31/no-strings-attached/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-12-31%20104222.png"></p>
<span id="more"></span>

<p><img src="/2021/12/31/no-strings-attached/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-12-31%20104903.png"></p>
<p>查找authenticate的汇编指令，我们注意到，加密函数的运算结果被保留到eax寄存器中</p>
<p><img src="/2021/12/31/no-strings-attached/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-12-31%20105226.png"></p>
<p>可以使用动态调试的方法</p>
<p>首先运行gdb</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gdb</span> ./<span class="literal">no</span>-strings-attached</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/no-strings-attached/Screenshot_2021-12-30_22-05-35.png"></p>
<p>然后在decrypt函数前下断点</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">b</span> decrypt</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/no-strings-attached/Screenshot_2021-12-30_22-06-04.png"></p>
<p>运行程序</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">r</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/no-strings-attached/Screenshot_2021-12-30_22-06-24.png"></p>
<p>运行一步</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">n</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/no-strings-attached/Screenshot_2021-12-30_22-06-40.png"></p>
<p>按照之前的分析，此时运行结果已经存到eax寄存器中，所以我们要做的就是读取eax寄存器中的值，关于命令的解释参考如下</p>
<p><a href="http://c.biancheng.net/view/7470.html">GDB查看内存 (biancheng.net)</a></p>
<p><a href="https://visualgdb.com/gdbreference/commands/x">GDB Command Reference - x command (visualgdb.com)</a></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">x</span>/<span class="number">200</span>wx $eax</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/no-strings-attached/Screenshot_2021-12-30_22-06-55.png"></p>
<p>运行如下脚本即得flag</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">key</span> <span class="operator">=</span> <span class="string">&quot;393434377b796f755f6172655f616e5f696e7465726e6174696f6e616c5f6d7973746572797d&quot;</span></span><br><span class="line"><span class="attribute">flag</span> <span class="operator">=</span> bytes.fromhex(key)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/31/no-strings-attached/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-12-31%20143731.png"></p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>re4-unvm-me</title>
    <url>/2022/01/11/re4-unvm-me/</url>
    <content><![CDATA[<h2 id="攻防世界-re4-unvm-me"><a href="#攻防世界-re4-unvm-me" class="headerlink" title="攻防世界-re4-unvm-me"></a>攻防世界-<a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=1&id=5033&page=1">re4-unvm-me</a></h2><p>下载文件为pyc文件，通过uncompyle6将其反编译为py文件，其中uncompyle6支持python2.6-3.8</p>
<p><img src="/2022/01/11/re4-unvm-me/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-01-11%20151300.png"></p>
<span id="more"></span>

<p>文件代码如下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uncompyle6 version 3.7.4</span></span><br><span class="line"><span class="comment"># Python bytecode 2.7 (62211)</span></span><br><span class="line"><span class="comment"># Decompiled from: Python 3.7.9 (tags/v3.7.9:13c94747c7, Aug 17 2020, 18:58:18) [MSC v.1900 64 bit (AMD64)]</span></span><br><span class="line"><span class="comment"># Embedded file name: unvm_me.py</span></span><br><span class="line"><span class="comment"># Compiled at: 2016-12-21 05:44:01</span></span><br><span class="line">import md5</span><br><span class="line">md5s = [</span><br><span class="line"> <span class="number">174282896860968005525213562254350376167</span>, <span class="number">137092044126081477479435678296496849608</span>, <span class="number">126300127609096051658061491018211963916</span>, <span class="number">314989972419727999226545215739316729360</span>, <span class="number">256525866025901597224592941642385934114</span>, <span class="number">115141138810151571209618282728408211053</span>, <span class="number">8705973470942652577929336993839061582</span>, <span class="number">256697681645515528548061291580728800189</span>, <span class="number">39818552652170274340851144295913091599</span>, <span class="number">65313561977812018046200997898904313350</span>, <span class="number">230909080238053318105407334248228870753</span>, <span class="number">196125799557195268866757688147870815374</span>, <span class="number">74874145132345503095307276614727915885</span>]</span><br><span class="line">print <span class="string">&#x27;Can you turn me back to python ? ...&#x27;</span></span><br><span class="line">flag = raw_input(<span class="string">&#x27;well as you wish.. what is the flag: &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> len(flag) &gt; <span class="number">69</span>:</span><br><span class="line">    print <span class="string">&#x27;nice try&#x27;</span></span><br><span class="line">    <span class="keyword">exit</span>()</span><br><span class="line"><span class="keyword">if</span> len(flag) % <span class="number">5</span> != <span class="number">0</span>:</span><br><span class="line">    print <span class="string">&#x27;nice try&#x27;</span></span><br><span class="line">    <span class="keyword">exit</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(flag), <span class="number">5</span>):</span><br><span class="line">    s = flag[i:i + <span class="number">5</span>]</span><br><span class="line">    <span class="keyword">if</span> int(<span class="string">&#x27;0x&#x27;</span> + md5.new(s).hexdigest(), <span class="number">16</span>) != md5s[(i / <span class="number">5</span>)]:</span><br><span class="line">        print <span class="string">&#x27;nice try&#x27;</span></span><br><span class="line">        <span class="keyword">exit</span>()</span><br><span class="line"></span><br><span class="line">print <span class="string">&#x27;Congratz now you have the flag&#x27;</span></span><br></pre></td></tr></table></figure>

<p>将md5s中的挨个解密即得flag</p>
<p>在线解密网站</p>
<p><a href="https://pmd5.com/">md5解密 MD5在线解密 破解md5 (pmd5.com)</a> &#x2F;&#x2F;免费</p>
<p><a href="https://cmd5.com/">md5在线解密破解,md5解密加密 (cmd5.com)</a> &#x2F;&#x2F;部分收费</p>
<p>最终求得flag</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">ALEXCTF&#123;dv<span class="number">5</span>d<span class="number">4</span>s<span class="number">2</span>vj<span class="number">8</span><span class="symbol">nk43</span>s<span class="number">8</span>d<span class="number">8</span>l<span class="number">6</span><span class="name">m1</span><span class="symbol">n5</span>l<span class="number">67</span>ds<span class="number">9</span>v<span class="number">41</span><span class="symbol">n52</span><span class="symbol">nv37</span>j<span class="number">481</span>h<span class="number">3</span>d<span class="number">28</span><span class="symbol">n4</span>b<span class="number">6</span>v<span class="number">3</span>k&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>从kali虚拟机向windows主机传程序步骤</title>
    <url>/2022/02/21/%E4%BB%8Ekali%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%91windows%E4%B8%BB%E6%9C%BA%E4%BC%A0%E7%A8%8B%E5%BA%8F%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>检查ssh服务状态，并将其开启</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo service ssh status</span></span><br></pre></td></tr></table></figure>

<p>如果没有安装，则使用命令</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install openssh-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>如果已安装但服务未启动，则使用命令</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">sudo service ssh <span class="literal">start</span></span><br></pre></td></tr></table></figure>

<p>如果已经按照了Xftp程序，此时可以用Xftp连接虚拟机，直接传递文件，具体步骤可参考韩顺平老师的教程</p>
<p><img src="/2022/02/21/%E4%BB%8Ekali%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%91windows%E4%B8%BB%E6%9C%BA%E4%BC%A0%E7%A8%8B%E5%BA%8F%E6%AD%A5%E9%AA%A4/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-21%20144223.png"></p>
<p>此外，也可以打开cmd用cd命令进入到文件将要被下载到的位置</p>
<p>使用scp命令</p>
<p>示例如下</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">scp kali<span class="variable">@192</span>.<span class="number">168.46</span>.<span class="number">128</span><span class="symbol">:/home/kali/Pictures/hello</span>.png .</span><br></pre></td></tr></table></figure>

<p>其中192.168.46.128为kali的ip地址，可在kali中使用ip ad命令或ifconfig命令查看</p>
<p>&#x2F;home&#x2F;kali&#x2F;Pictures为文件在kali中的地址</p>
<p>hello.png为文件名</p>
<p> .不可少且前有空格</p>
]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>复旦白泽暑期课程逆向入门课wp</title>
    <url>/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/</url>
    <content><![CDATA[<h2 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h2><p>首先用ida64打开re2文件，定位到main函数</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/main.png"></p>
<span id="more"></span>

<p>f5反汇编得到如下代码</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(int a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned<span class="built_in"> int </span>v3; // eax</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned<span class="built_in"> int </span>v5; // [rsp+4h] [rbp-1Ch]</span><br><span class="line">  unsigned<span class="built_in"> int </span>v6; // [rsp+8h] [rbp-18h]</span><br><span class="line">  unsigned<span class="built_in"> int </span>v7; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  unsigned<span class="built_in"> int </span>v8; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned<span class="built_in"> int </span>v9; // [rsp+14h] [rbp-Ch]</span><br><span class="line"> <span class="built_in"> int </span>v10; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  puts(<span class="string">&quot;hi all ----------------------&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;Welcome to dice game!&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;You have to roll 5 dices and get 6, 6, 6, 6, 6 in order.&quot;</span>);</span><br><span class="line">  puts(<span class="string">&quot;Press enter to roll.&quot;</span>);</span><br><span class="line">  getchar();</span><br><span class="line">  v3 = time(0<span class="class">LL);</span></span><br><span class="line">  srand(v3);</span><br><span class="line">  v10 = time(0<span class="class">LL);</span></span><br><span class="line">  v9 = rand() % 6 + 1;</span><br><span class="line">  v8 = rand() % 6 + 1;</span><br><span class="line">  v7 = rand() % 6 + 1;</span><br><span class="line">  v6 = rand() % 6 + 1;</span><br><span class="line">  v5 = rand() % 6 + 1;</span><br><span class="line">  printf(<span class="string">&quot;You rolled %d, %d, %d, %d, %d.\n&quot;</span>, v9, v8, v7, v6, v5);</span><br><span class="line"> <span class="built_in"> if </span>( v9 != 6 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_15;</span></span><br><span class="line"> <span class="built_in"> if </span>( time(0LL) - v10 &gt; 2 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_13;</span></span><br><span class="line"> <span class="built_in"> if </span>( v8 != 6 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_15;</span></span><br><span class="line"> <span class="built_in"> if </span>( time(0LL) - v10 &gt; 2 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_13;</span></span><br><span class="line"> <span class="built_in"> if </span>( v7 != 6 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_15;</span></span><br><span class="line"> <span class="built_in"> if </span>( time(0LL) - v10 &gt; 2 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_13;</span></span><br><span class="line"> <span class="built_in"> if </span>( v6 != 6 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_15;</span></span><br><span class="line"> <span class="built_in"> if </span>( time(0LL) - v10 &gt; 2 )</span><br><span class="line">   <span class="built_in"> goto </span><span class="class">LABEL_13;</span></span><br><span class="line"> <span class="built_in"> if </span>( v5 == 6 )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( time(0LL) - v10 &gt; 2 )</span><br><span class="line">    &#123;</span><br><span class="line">LABEL_13:</span><br><span class="line">      puts(<span class="string">&quot;No cheat!&quot;</span>);</span><br><span class="line">     <span class="built_in"> return </span>0xFFFFFFFF<span class="class">LL;</span></span><br><span class="line">    &#125;</span><br><span class="line">    puts(<span class="string">&quot;You rolled as I said! I&#x27;ll give you the flag.&quot;</span>);</span><br><span class="line">    sub_4006B6();</span><br><span class="line">    result = 0<span class="class">LL;</span></span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_15:</span><br><span class="line">    puts(<span class="string">&quot;You DID NOT roll as I said!&quot;</span>);</span><br><span class="line">    puts(<span class="string">&quot;Bye bye~&quot;</span>);</span><br><span class="line">    result = 0xFFFFFFFF<span class="class">LL;</span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in"> return </span>result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析得知，这是一个摇骰子的游戏，v5到v9是1到6的时间种子随机数，要求v5到v9都是6，且time(0LL) - v10 &gt; 2两个条件都满足才能执行 sub_4006B6()函数，输出正确的flag，而v10 &#x3D; time(0LL)，所以第二个条件无法满足，想到用patch的方法修改判断条件</p>
<p>查看对应汇编代码我们能找到如下指令</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/tiaojian1.png"></p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/tiaojian2.png"></p>
<p>类似的条件共有5组，第一个条件对应摇出数字6，第二个条件对应time(0LL) - v10 &gt; 2，现更改汇编，使第一类跳转不执行，第二类跳转均执行，使用keypatcher插件，将第一个条件中的6改为0，由于随机数的范围是1到6所以一定与0不等，再将jnz改为jz，则跳转一定不执行，将第二个条件中的jle改为jmp，则跳转一定执行，如下图所示</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/keypatcher.png"></p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/patch1.png"></p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/patch2.png"></p>
<p>将5组条件均进行相同的修改，然后保存</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/baocun.png"></p>
<p>将保存后的re2文件放在linux下执行，运行得到flag</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/flag_re2.png"></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flag</span>&#123;<span class="number">4</span>b34098e229eab72739923a0b40b3be6&#125;</span><br></pre></td></tr></table></figure>

<h2 id="re3"><a href="#re3" class="headerlink" title="re3"></a>re3</h2><p>首先用ida64打开re3文件，定位到main函数，f5得到如下伪代码</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">![re3_address](%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re3_address.png)__int64 __fastcall main(<span class="keyword">int</span> a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  char v5; <span class="comment">// bp</span></span><br><span class="line">  char v6; <span class="comment">// al</span></span><br><span class="line">  const char *v7; <span class="comment">// rdi</span></span><br><span class="line">  unsigned <span class="keyword">int</span> v9; <span class="comment">// [rsp+0h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v10[<span class="number">9</span>]; <span class="comment">// [rsp+4h] [rbp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v10[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  puts(<span class="string">&quot;Give  flag:&quot;</span>);</span><br><span class="line">  scanf(<span class="string">&quot;%s&quot;</span>, &amp;s1);</span><br><span class="line">  <span class="keyword">if</span> ( strlen(&amp;s1) != <span class="number">26</span> || strncmp(&amp;s1, <span class="string">&quot;flag&#123;&quot;</span>, <span class="number">5</span>uLL) || *(&amp;byte_6010BF + <span class="number">26</span>) != <span class="number">125</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">    puts(<span class="string">&quot;Wrong flag!&quot;</span>);</span><br><span class="line">    exit(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">5</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( strlen(&amp;s1) - <span class="number">1</span> &gt; <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = *(&amp;s1 + v3);</span><br><span class="line">      v5 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &gt; <span class="number">67</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (unsigned __int8)v4 == <span class="number">68</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = sub_400650(v10);</span><br><span class="line">          goto LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (unsigned __int8)v4 == <span class="number">69</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = sub_400660(v10);</span><br><span class="line">          goto LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (unsigned __int8)v4 == <span class="number">65</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = sub_400670(&amp;v9);</span><br><span class="line">          goto LABEL_14;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (unsigned __int8)v4 == <span class="number">66</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = sub_400680(&amp;v9);</span><br><span class="line">LABEL_14:</span><br><span class="line">          v5 = v6;</span><br><span class="line">          goto LABEL_15;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_15:</span><br><span class="line">      <span class="keyword">if</span> ( !(unsigned __int8)sub_400690(asc_601060, (unsigned <span class="keyword">int</span>)v10[<span class="number">0</span>], v9) )</span><br><span class="line">        goto LABEL_22;</span><br><span class="line">      <span class="keyword">if</span> ( ++v3 &gt;= strlen(&amp;s1) - <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">LABEL_20:</span><br><span class="line">        v7 = <span class="string">&quot;Wrong flag!&quot;</span>;</span><br><span class="line">        goto LABEL_21;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( asc_601060[<span class="number">8</span> * v9 + v10[<span class="number">0</span>]] != <span class="number">42</span> )</span><br><span class="line">    goto LABEL_20;</span><br><span class="line">  v7 = <span class="string">&quot;Congratulations!&quot;</span>;</span><br><span class="line">LABEL_21:</span><br><span class="line">  puts(v7);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序大体逻辑是输出一个Give  flag:，然后将我们输入的字符串长度为26，存入s1数组，根据判断条件知s1数组的前五位为flag{先随意试一下</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re3_try.png"></p>
<p>双击byte_6010BF，发现它是s1的前一位，则*(&amp;byte_6010BF + 26)对应s1的最后一位，利用ida可将125转换为对应的字符”}”</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re3_address.png"></p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/char.png"></p>
<p>那我们的任务就是判断剩下的20个字符，它们存储在v4数组中，利用转换字符的功能，可以将68、69、65、66依次转换为D、E、A、B，继续分析，我们注意到判断flag正确与否的关键在这个地方</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re3_key.png"></p>
<p>双击asc_601060发现它是这样的字符串</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re3_maze.png"></p>
<p>典型的迷宫问题，42对应”*”，这个字符即为出口，根据asc_601060[8 * v9 + v10[0]]，判断出迷宫的行号对应v9，列号对应v10[0]，且每行有8列，先把迷宫整理一下，为便于观察用”#”代替” “</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/maze.png"></p>
<p>将v9、v10[0]改名为row、column，根据函数判断出</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/sxzy.png"></p>
<p>再根据第57行的sub_400690函数判断出空格和*可走</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/panduan.png"></p>
<p>则得出flag为</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">flag</span><span class="template-variable">&#123;EBEEBBDBBBEEEEAADAAE&#125;</span></span><br></pre></td></tr></table></figure>

<p>验证</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re3_flag.png"></p>
<h2 id="re1思考题"><a href="#re1思考题" class="headerlink" title="re1思考题"></a>re1思考题</h2><p>由于scanf %s有可能造成溢出，且程序中没有对输入字符串的长度进行检验，所以在正确的flag后，加上任意的字符也会puts(“you are right!”)</p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/scanf.png"></p>
<p><img src="/2021/07/18/%E5%A4%8D%E6%97%A6%E7%99%BD%E6%B3%BD%E6%9A%91%E6%9C%9F%E8%AF%BE%E7%A8%8B%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E8%AF%BEwp/re1_bug.png"></p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界Babyre</title>
    <url>/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/</url>
    <content><![CDATA[<h2 id="攻防世界Babyre"><a href="#攻防世界Babyre" class="headerlink" title="攻防世界Babyre"></a>攻防世界<a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=1&id=4662&page=1">Babyre</a></h2><p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20154137.png"></p>
<p>关键在于judge函数,judge函数无法正确反编译，显然是被加密了，main函数第8行即为加密过程</p>
<span id="more"></span>

<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20154437.png"></p>
<p>方法一：用ida python解密</p>
<p>已知judge函数的起始地址为0x600B00，且已知judge函数共182个字节，可以用ida python还原加密前的judge函数</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20161641.png"></p>
<p>运行如上脚本，发现数值发生了变化</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20161758.png"></p>
<p>然后按U（取消原来定义），再按 C（重新生成汇编代码），按P（重新生成 function）后即可f5反编译，得到加密前的judge函数</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20162051.png"></p>
<p>脚本如下</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">v2_str = &#x27;fmcd&#x27;</span><br><span class="line">v2 = []</span><br><span class="line">for x in v2_str:</span><br><span class="line">    v2.append(ord(x))</span><br><span class="line">v2.append(127)</span><br><span class="line">v3 = &#x27;k7d;V`;np&#x27;</span><br><span class="line">for x in v3:</span><br><span class="line">    v2.append(ord(x))</span><br><span class="line">for i in range(0,14):</span><br><span class="line">    v2[i] ^= i</span><br><span class="line">for i in v2:</span><br><span class="line">    print(chr(i),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure>

<p>运行既得flag</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20164050.png"></p>
<p>方法二：注意到main函数的第8行即为解密judge函数的过程，所以可以采用动态调试的方法求解judge函数</p>
<p>由于文件为elf文件，所以将ida的dbgsrv得linux_server64复制到linux虚拟机中，在ida种启动远程调试，断点下在12行即可</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20165405.png"></p>
<p>此时judge函数已解密，双击进入</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20165538.png"></p>
<p>同样执行U、C、P后按f5即可看到解密后的函数</p>
<p><img src="/2022/02/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CBabyre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-09%20165601.png"></p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界gametime</title>
    <url>/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/</url>
    <content><![CDATA[<h2 id="Gametime"><a href="#Gametime" class="headerlink" title="Gametime"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=1&id=5005&page=2">Gametime</a></h2><p>这是一道有趣的游戏题，运行程序，它会先跟你介绍规则，如果看到s的话就按空格键，如果看到x的话就按x键，如果看到m的话就按m键，如果手速够快的话可以通过玩游戏通关，作为一道逆向题的话我用了两种作法</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20205613.png"></p>
<span id="more"></span>

<p>做法一：动态调试，我用的工具为x32dbg，这里也是学习了别人的思路</p>
<p>“通过刚刚玩游戏发现程序有输入的地方，那么我们猜测这个题的做法：F8的时候程序一定会在某个地方停住，下断点，重新载入，F9，在下断点的地方按F7，进入跟踪，然后F8……，一直循环，直到发现有用的函数。”</p>
<p>程序载入x32dbg</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20211324.png"></p>
<p>F8单步走，走到不能动的地方下断点</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/2022-02-22_212406.png"></p>
<p>Ctrl+F2重新载入，F9，然后F7进入函数</p>
<p>然后一直F8走到不能动的地方，再下一个断点</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20213327.png"></p>
<p>再重新载入，F9到下的第一个断点处，现在我们可以把这里的断点去掉了。然后F9到第二个断点处。</p>
<p>重复上面的操作，直到找到输出s的函数，如下</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20215420.png"></p>
<p>执行call gametime.301260时，程序会输出s，并检测输入，如果输入空格，则当程序执行完test al,al，ZF标志位会置1，下一条jne指令就会跳转，如果输入错误就会跳转失败，继续执行就会输出错误语句，当然，我们可以随便输入，只要在执行jne语句前手动将ZF标志位置1即可</p>
<p>上图为练习环节的关键函数，调试程序就会发现无论是输出s还是x，m，都是通过调用gametime.301260函数实现的，都会跳转到上图下断点的指令</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20220655.png"></p>
<p>这段是正式游戏阶段的关键函数，可以看到，还是调用了gametime.301260函数，不过指令的地址不同，通过在这两个位置下断点，不断运行并保证jne跳转始终执行就能得到最终的flag</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/2022-02-22_200636.png"></p>
<p>方法二：patch程序</p>
<p>引用官方wp(直呼学到了)</p>
<p><img src="/2022/02/23/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cgametime/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20221256.png"></p>
<p>将下图中的jne改为je(另外一处做相同操作)，再Apply patches to input file，再执行程序，只要错误输入或不输入就能得到正确的flag</p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>攻防世界testre</title>
    <url>/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/</url>
    <content><![CDATA[<h2 id="Testre"><a href="#Testre" class="headerlink" title="Testre"></a><a href="https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=1&id=5476&page=1">Testre</a></h2><p>用ida打开文件找到main函数可看到两个关键函数</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/2022-02-18_174614.png"></p>
<span id="more"></span>

<p>查看函数sub_400D00（成功加载）</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/2022-02-18_175804.png"></p>
<p>再查看函数sub_400700，可以看到，函数十分复杂</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall sub_400700(void *a1, _QWORD *a2, __int64 a3, size_t a4)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int8 *v4; // rcx</span><br><span class="line">  _DWORD v6[2]; // [rsp+0h] [rbp-C0h] BYREF</span><br><span class="line"> <span class="built_in"> int </span>c; // [rsp+8h] [rbp-B8h]</span><br><span class="line">  char v8; // [rsp+Fh] [rbp-B1h]</span><br><span class="line"> <span class="built_in"> int </span>v9; // [rsp+10h] [rbp-B0h]</span><br><span class="line">  bool v10; // [rsp+17h] [rbp-A9h]</span><br><span class="line">  unsigned __int8 *v11; // [rsp+18h] [rbp-A8h]</span><br><span class="line">  char v12; // [rsp+27h] [rbp-99h]</span><br><span class="line"> <span class="built_in"> int </span>v13; // [rsp+28h] [rbp-98h]</span><br><span class="line"> <span class="built_in"> int </span>v14; // [rsp+2Ch] [rbp-94h]</span><br><span class="line">  unsigned __int64 i; // [rsp+30h] [rbp-90h]</span><br><span class="line">  size_t n; // [rsp+38h] [rbp-88h]</span><br><span class="line">  size_t v17; // [rsp+40h] [rbp-80h]</span><br><span class="line">  size_t v18; // [rsp+48h] [rbp-78h]</span><br><span class="line">  size_t j; // [rsp+50h] [rbp-70h]</span><br><span class="line">  size_t v20; // [rsp+58h] [rbp-68h]</span><br><span class="line"> <span class="built_in"> int </span>v21; // [rsp+64h] [rbp-5Ch]</span><br><span class="line">  unsigned __int64 v22; // [rsp+68h] [rbp-58h]</span><br><span class="line"> <span class="built_in"> int </span>v23; // [rsp+74h] [rbp-4Ch]</span><br><span class="line">  _DWORD *v24; // [rsp+78h] [rbp-48h]</span><br><span class="line">  __int64 v25; // [rsp+80h] [rbp-40h]</span><br><span class="line">  void *v26; // [rsp+88h] [rbp-38h]</span><br><span class="line"> <span class="built_in"> int </span>v27; // [rsp+94h] [rbp-2Ch]</span><br><span class="line">  size_t v28; // [rsp+98h] [rbp-28h]</span><br><span class="line">  __int64 v29; // [rsp+A0h] [rbp-20h]</span><br><span class="line">  _QWORD *v30; // [rsp+A8h] [rbp-18h]</span><br><span class="line">  void *s; // [rsp+B0h] [rbp-10h]</span><br><span class="line">  char v32; // [rsp+BFh] [rbp-1h]</span><br><span class="line">  </span><br><span class="line">  s = a1;</span><br><span class="line">  v30 = a2;</span><br><span class="line">  v29 = a3;</span><br><span class="line">  v28 = a4;</span><br><span class="line">  v27 = -559038737;</span><br><span class="line">  v26 = malloc(0x100u<span class="class">LL);</span></span><br><span class="line">  v25 = v29;</span><br><span class="line">  v24 = v6;</span><br><span class="line">  v22 = 0<span class="class">LL;</span></span><br><span class="line">  v17 = 0<span class="class">LL;</span></span><br><span class="line">  for ( i = 0<span class="class">LL;</span> i &lt; v28; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v13 = *(unsigned __int8 *)(v25 + i);</span><br><span class="line">    *((_BYTE *)v26 + i) = byte_400E90[i % 0x1D] ^ v13;</span><br><span class="line">    *((_BYTE *)v26 + i) += *(_BYTE *)(v25 + i);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = 0;</span><br><span class="line">   <span class="built_in"> if </span>( v17 &lt; v28 )</span><br><span class="line">      v12 = ~(*(_BYTE *)(v25 + v17) != 0);</span><br><span class="line">   <span class="built_in"> if </span>( (v12 &amp; 1) == 0 )</span><br><span class="line">      break;</span><br><span class="line">    ++v17;</span><br><span class="line">  &#125;</span><br><span class="line">  n = 138 * (v28 - v17) / 0x64 + 1;</span><br><span class="line">  v23 = ((v17 + v28) &lt;&lt; 6) / 0x30 - 1;</span><br><span class="line">  v11 = (unsigned __int8 *)v6 - ((138 * (v28 - v17) / 0x64 + 16) &amp; 0xFFFFFFFFFFFFFFF0<span class="class">LL);</span></span><br><span class="line">  memset(v11, 0, n);</span><br><span class="line">  v20 = v17;</span><br><span class="line">  v18 = n - 1;</span><br><span class="line">  while ( v20 &lt; v28 )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = *(unsigned __int8 *)(v25 + v20);</span><br><span class="line">    for ( j = n - 1; ; --j )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = 1;</span><br><span class="line">     <span class="built_in"> if </span>( j &lt;= v18 )</span><br><span class="line">        v10 = v21 != 0;</span><br><span class="line">     <span class="built_in"> if </span>( !v10 )</span><br><span class="line">        break;</span><br><span class="line">      v22 = v11[j] &lt;&lt; 6;</span><br><span class="line">      v21 += v11[j] &lt;&lt; 8;</span><br><span class="line">      v9 = 64;</span><br><span class="line">      v11[j] = v21 % 58;</span><br><span class="line">      *((_BYTE *)v26 + j) = v22 &amp; 0x3F;</span><br><span class="line">      v22 &gt;&gt;= 6;</span><br><span class="line">      v21 /= 58;</span><br><span class="line">      v27 /= v9;</span><br><span class="line">     <span class="built_in"> if </span>( !j )</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v20;</span><br><span class="line">    v18 = j;</span><br><span class="line">  &#125;</span><br><span class="line">  for ( j = 0<span class="class">LL;</span> ; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = 0;</span><br><span class="line">   <span class="built_in"> if </span>( j &lt; n )</span><br><span class="line">      v8 = ~(v11[j] != 0);</span><br><span class="line">   <span class="built_in"> if </span>( (v8 &amp; 1) == 0 )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in"> if </span>( *v30 &gt; n + v17 - j )</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in"> if </span>( v17 )</span><br><span class="line">    &#123;</span><br><span class="line">      c = 61;</span><br><span class="line">      memset(s, 49, v17);</span><br><span class="line">      memset(v26, c, v17);</span><br><span class="line">    &#125;</span><br><span class="line">    v20 = v17;</span><br><span class="line">    while ( j &lt; n )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = v11;</span><br><span class="line">      *((_BYTE *)s + v20) = byte_400EB0[v11[j]];</span><br><span class="line">      *((_BYTE *)v26 + v20++) = byte_400EF0[v4[j++]];</span><br><span class="line">    &#125;</span><br><span class="line">    *((_BYTE *)s + v20) = 0;</span><br><span class="line">    *v30 = v20 + 1;</span><br><span class="line">   <span class="built_in"> if </span>( !strncmp((const char *)s, <span class="string">&quot;D9&quot;</span>, 2uLL)</span><br><span class="line">      &amp;&amp; !strncmp((const char *)s + 20, <span class="string">&quot;Mp&quot;</span>, 2uLL)</span><br><span class="line">      &amp;&amp; !strncmp((const char *)s + 18, <span class="string">&quot;MR&quot;</span>, 2uLL)</span><br><span class="line">      &amp;&amp; !strncmp((const char *)s + 2, <span class="string">&quot;cS9N&quot;</span>, 4uLL)</span><br><span class="line">      &amp;&amp; !strncmp((const char *)s + 6, <span class="string">&quot;9iHjM&quot;</span>, 5uLL)</span><br><span class="line">      &amp;&amp; !strncmp((const char *)s + 11, <span class="string">&quot;LTdA8YS&quot;</span>, 7uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      v6[1] = puts(<span class="string">&quot;correct!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v32 = 1;</span><br><span class="line">    v14 = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    *v30 = n + v17 - j + 1;</span><br><span class="line">    v32 = 0;</span><br><span class="line">    v14 = 1;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in"> return </span>v32 &amp; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将s与一串字符进行比较</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20112701.png"></p>
<p>参考别人的wp，发现程序中大多数都是无用的混淆代码，关键部分如下</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/2022-02-22_113025.png"></p>
<p>这里出现了v11</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/2022-02-22_113525.png"></p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/2022-02-22_113752.png"></p>
<p><a href="https://blog.csdn.net/aozeahj/article/details/52507352">base64加密原理</a></p>
<p><a href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">base系列浅析</a></p>
<p>官方wp是这么说的</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20114442.png"></p>
<p>所以最后比较的就是输入后的baee58加密是否相等，那拿D9cS9N9iHjMLTdA8YSMRMp<a href="http://www.hiencode.com/">在线解密</a>即可得到flag：</p>
<p><img src="/2022/02/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Ctestre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-02-22%20114655.png"></p>
]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2019红帽杯childre</title>
    <url>/2022/03/05/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildre/</url>
    <content><![CDATA[<h2 id="childRe"><a href="#childRe" class="headerlink" title="childRe"></a><a href="https://buuoj.cn/challenges#[2019%E7%BA%A2%E5%B8%BD%E6%9D%AF]childRE">childRe</a></h2><p>main函数如下</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">int __cdecl main(int argc,<span class="built_in"> const </span>char **argv,<span class="built_in"> const </span>char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 v4; // rax</span><br><span class="line"> <span class="built_in"> const </span>CHAR *v5; // r11</span><br><span class="line">  __int64 v6; // r10</span><br><span class="line"> <span class="built_in"> int </span>v7; // er9</span><br><span class="line"> <span class="built_in"> const </span>CHAR *v8; // r10</span><br><span class="line">  __int64 v9; // rcx</span><br><span class="line">  __int64 *v10; // rax</span><br><span class="line">  unsigned<span class="built_in"> int </span>v12; // ecx</span><br><span class="line">  __int64 v13; // r9</span><br><span class="line">  __int64 v14; // r8</span><br><span class="line">  __int64 v15; // rdx</span><br><span class="line">  __int128 v16[2]; // [rsp+20h] [rbp-38h] BYREF</span><br><span class="line"></span><br><span class="line">  memset(v16, 0, sizeof(v16));</span><br><span class="line">  sub_7FF6BF3D1080(<span class="string">&quot;%s&quot;</span>, (const char *)v16);    // 输入字符串存入v14</span><br><span class="line">  v3 = -1i64;                                   // v3初始值为-1</span><br><span class="line">  do</span><br><span class="line">    ++v3;</span><br><span class="line">  while ( *((_BYTE *)v16 + v3) );               // 0123456789qwertyuiopasdfghjklzx</span><br><span class="line"> <span class="built_in"> if </span>( v3 != 31 )                               // 限制输入字符串长度为31</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">      Sleep(0x3E8u);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = sub_7FF6BF3D1280(v16);</span><br><span class="line">  v5 = name;</span><br><span class="line"> <span class="built_in"> if </span>( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_7FF6BF3D15C0(*(_QWORD *)(v4 + 8));</span><br><span class="line">    sub_7FF6BF3D15C0(*(_QWORD *)(v6 + 16));</span><br><span class="line">    v7 = dword_7FF6BF3D57E0;</span><br><span class="line">    v5[dword_7FF6BF3D57E0] = *v8;</span><br><span class="line">    dword_7FF6BF3D57E0 = v7 + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  UnDecorateSymbolName(v5, outputString, 0x100u, 0);</span><br><span class="line">  v9 = -1i64;</span><br><span class="line">  do</span><br><span class="line">    ++v9;</span><br><span class="line">  while ( outputString[v9] );</span><br><span class="line"> <span class="built_in"> if </span>( v9 == 62 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = 0;</span><br><span class="line">    v13 = 0i64;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v14 = outputString[v13] % 23;</span><br><span class="line">     <span class="built_in"> if </span>( a1234567890Qwer[v14] != a46200860044218[v13] )</span><br><span class="line">        _exit(v12);</span><br><span class="line">      v15 = outputString[v13] / 23;</span><br><span class="line">     <span class="built_in"> if </span>( a1234567890Qwer[v15] != a55565653255552[v13] )</span><br><span class="line">        _exit(v12 * v12);</span><br><span class="line">      ++v12;</span><br><span class="line">      ++v13;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( v12 &lt; 62 );</span><br><span class="line">    sub_7FF6BF3D1020(<span class="string">&quot;flag&#123;MD5(your input)&#125;\n&quot;</span>, v15, v14, v13);</span><br><span class="line">   <span class="built_in"> return </span>0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = sub_7FF6BF3D18A0(std::cout);</span><br><span class="line">    std::ostream::operator&lt;&lt;(v10, sub_7FF6BF3D1A60);</span><br><span class="line">   <span class="built_in"> return </span>-1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>首先求出outputString</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">str1 = &#x27;<span class="number">1234567890</span>-=!@#$%^&amp;*()_+qwertyuiop[]QWERTYUIOP&#123;&#125;asdfghjkl;&#x27;+ chr(<span class="number">0</span>x27) + &#x27;A&#x27; + &#x27;SDFGHJKL:&quot;ZXCVBNM&lt;&gt;?zxcvbnm,./&#x27;</span><br><span class="line">str2 = &#x27;(_@<span class="number">4620</span>!08!6_0*<span class="number">0442</span>!@186%%0@3=66!!974*<span class="number">3234</span>=&amp;0^3&amp;1@=&amp;<span class="number">0908</span>!6_0*&amp;&#x27;</span><br><span class="line">str3 = &#x27;<span class="number">55565653255552</span><span class="number">22556556555524</span><span class="number">34663346536635</span><span class="number">44426565555525</span><span class="number">555222</span>&#x27;</span><br><span class="line">input = &#x27;&#x27;</span><br><span class="line">for i in range(<span class="number">62</span>):</span><br><span class="line">    m = str1.index(str2[i])</span><br><span class="line">    n = str1.index(str3[i])</span><br><span class="line">    input += chr((n*<span class="number">23</span>+m)%<span class="number">128</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure>

<p>运行结果为一个函数名<code>private: char * __thiscall R0Pxx::My_Aut0_PWN(unsigned char *)</code></p>
<p>关键函数为UnDecorateSymbolName，功能为让函数更容易识别</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>参考链接：</p>
<p><a href="https://www.cnblogs.com/yxysuanfa/p/6984895.html">C++ 编译器的函数名修饰规则 - yxysuanfa - 博客园 (cnblogs.com)</a></p>
<ul>
<li>参考资料1<br>第二个参数为未修饰的名字，第三个参数为长度，第四个参数为0表示完全修饰，第一个参数为输出地址</li>
<li>参考材料2<br>c++函数名的修饰更为复杂，提供的信息也更为丰富。<br>无论 __cdecl，__fastcall还是__stdcall调用方式，函数修饰都是以一个“?”开始，后面紧跟函数的名字。再后面是参数表的开始标识和依照参数类型代号拼出的参数表。</li>
</ul>
<p>v5 &#x3D; ?My_Aut0_PWN</p>
<ul>
<li>对于C++的类成员函数(其调用方式是thiscall)，函数的名字修饰与非成员的C++函数稍有不同，首先就是在函数名字和参数表之间插入以“@”字 符引导的类名</li>
</ul>
<p>v5 &#x3D; ?My_Aut0_PWN@R0Pxx</p>
<ul>
<li>其次是参数表的开始标识不同，公有（public）成员函数的标识是“@@QAE”，保护（protected）成员函数的标识是 “@@IAE”，私有(private)成员函数的标识是“@@AAE”，假设函数声明使用了constkeyword，则对应的标识应分别为“@@QBE”，“@@IBE”和“@@ABE”。</li>
</ul>
<p>因为函数为 private，私有成员<br>所以 v5 &#x3D; ?My_Aut0_PWN@R0Pxx@@AAE<br>后面就是添加参数了，先加入函数返回值参数，函数的返回值类型为char *</p>
<ul>
<li>参数表的拼写代号如下：<br>X–void<br>D–char<br>E–unsigned char<br>F–short<br>H–int<br>I–unsigned int<br>J–long<br>K–unsigned long（DWORD）<br>M–float<br>N–double<br>_N–bool<br>U–struct<br>…<br>指针的方式有些特别。用PA表示指针，用PB表示const类型的指针。</li>
</ul>
<p>char *也就是PAD<br>所以 v5 &#x3D; ?My_Aut0_PWN@R0Pxx@@AAEPAD<br>然后是参数的类型 unsigned char *，也就是PAE<br>所以 v5 &#x3D; ?My_Aut0_PWN@R0Pxx@@AAEPADPAE</p>
<ul>
<li>参数表后以“@Z”标识整个名字的结束。假设该函数无参数，则以“Z”标识结束。</li>
</ul>
<p>所以最终v5 &#x3D; ?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>另外一种方法参考 <a href="https://www.cnblogs.com/Mayfly-nymph/p/11869959.html#%E7%BD%AE%E6%8D%A2%E8%BF%90%E7%AE%97">Hk_Mayfly</a> 师傅的博客：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R0Pxx</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">R0Pxx</span>() &#123;</span><br><span class="line">        <span class="built_in">My_Aut0_PWN</span>((<span class="type">unsigned</span> <span class="type">char</span>*)<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span>* __thiscall <span class="title">My_Aut0_PWN</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* __thiscall <span class="title">R0Pxx::My_Aut0_PWN</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R0Pxx A;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;PAUSE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到：?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z</span></span><br></pre></td></tr></table></figure>

<p>接下来看上面的置换操作</p>
<p><img src="/2022/03/05/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-03-05%20121620.png"></p>
<p>可以采用动态调试打表的方法</p>
<p>输入串<code>0123456789qwertyuiopasdfghjklzx</code>查看输出</p>
<p><img src="/2022/03/05/2019%E7%BA%A2%E5%B8%BD%E6%9D%AFchildre/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-03-05%20121959.png"></p>
<p>即可求得flag</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">str1 = <span class="string">&#x27;0123456789qwertyuiopasdfghjklzx&#x27;</span></span><br><span class="line">decoded_str1 = <span class="string">&#x27;yu7io83pa9sdq41fgwhje5klrzxt620&#x27;</span></span><br><span class="line">enc = <span class="string">&#x27;&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;?My_Aut0_PWN@R0Pxx@@AAEPADPAE@Z&#x27;</span></span><br><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">    enc += str2<span class="selector-attr">[decoded_str1.index(str1[i]</span>)]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">&#x27;flag&#123;&#x27;</span> + hashlib.md5(enc.encode(<span class="string">&quot;utf-8&quot;</span>)</span></span>)<span class="selector-class">.hexdigest</span>() + <span class="string">&#x27;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF刷题记录</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
</search>
